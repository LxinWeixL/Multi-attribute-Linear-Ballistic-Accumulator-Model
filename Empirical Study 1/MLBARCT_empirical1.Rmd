---
title: "MLBA model on Empirical Study 1"
author: "Xinwei Li\n li.xinwei@u.nus.edu"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
      highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

```

# 1. Data import
```{r, echo=FALSE, message=FALSE,results='hide'}
library(tictoc)
library(doParallel)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
library(RcppNumerical)
library(plyr)
library(data.table)
library(readr)
library(crayon)
library(ggplot2)
library(bayestestR)


file_route = "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\MLBA.cpp"
df_raw = read.csv("Empirical_Data1.csv")
sourceCpp(file_route)
head(df_raw) # stored in long format
```


# 2. MLBA prepration
## 2.1 hyperparameter setting

```{r}
true_param = list(A_b = 1,s0 = 1,lam1 = 1,lam2 = 0,alpha = -1,zeta = c(0,0,1),type = 1,  attention = 0,beta = c(0,0,0)) 

nAttr = 2 # TC and DR
nAlt = length(unique(df_raw$alt))
npar =(nAlt-2)+ nAttr + 1 + 1 
zeta_index =(nAttr+1):(nAlt+nAttr-2)
npar;zeta_index
```


## 2.2 De-MCMC setup
```{r}

# function to retrive choice-RT and attribute infos from given dataframe
 df_info = function(df){
  res = list()  # four iterms: N;attrs;RC;RT
  # observation number
  res$N = nrow(df)/nAlt
  # chosen choice 
  tmp = matrix(df$alt*df$chosen,nrow = nAlt,byrow = FALSE)
  rc_f = function(res){
    tmp = res
    if(res==3)tmp = 2
    else if(res==4) tmp = 3
    return(tmp)
  }
  res$RC = sapply(1:res$N, function(x){  rc_f(sum(tmp[,x]))})
 # response time
  res$RT= t(matrix(df$rt,nrow = nAlt))[,1]
 # attribute matrix
  attrs = matrix(nrow = res$N*nAlt,ncol = nAttr)
  ## TC = RC+ OC*monthly working days
  attrs[,1] = -(df$RC+df$workdays*df$OC*52/12)
  ## log(DR)
  attrs[,2] = log(df$DR)
  ## normalized attributes value to [0,1]
  attrs = sapply(1:nAttr, function(x){(attrs[,x]-min(attrs[,x]))/(max(attrs[,x])-min(attrs[,x]))})
  res$attrs = attrs
  
  return(res)
}

##########################################
# self-designed parameter transformation 
para_fun=function(para){
  current_para_list = list()
  current_para_list$beta = para[1:nAttr]
  current_para_list$zeta = c(para[(nAttr+1)]+true_param$zeta[nAlt],true_param$zeta[nAlt],true_param$zeta[nAlt])

  current_para_list$lam1 = para[npar-1]
  current_para_list$lam2 = true_param$lam2  #para[npar-1]
  current_para_list$A = para[npar]*true_param$A_b
  current_para_list$b = para[npar]
  current_para_list$s0 =true_param$s0
  return(current_para_list)
}

###########################################################
# function to return the log-posterior of given parameter
poster = function(para_list){
  
  para = as.numeric(para_list$para)
  type = para_list$type
  prior = rep(-1,length(para))
  if(length(zeta_index)!=0){
    prior[zeta_index] = dunif(para[zeta_index], min = -100, max = 100,log = T)
    prior[-zeta_index] = dunif(para[-zeta_index], min = 0, max = 200,log = T)
  }else{
    prior = dunif(para, min = 0, max = 200,log = T)
  }
  
  prior[npar-1] =  dunif(para[npar-1], min = 0, max = 5,log = T)
  
 
  
  para_tmp = para_fun(para = para)
  
if(type=="CRT"){
 temp = sum(prior) +  RCPPMLBA_Lik_rtknown(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
   
}else if(type=="RTG"){
  temp = sum(prior) +  RCPPMLBA_Lik_rtg(X = attrs,beta = para_tmp$beta, zeta = para_tmp $zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
    
}else{
  temp = sum(prior) + RCPPMLBA_Lik_CO(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC)
    
}
  if(is.na(temp)) temp = -Inf
  
  return (temp)
}
############################################
# initial function
chain_intial = function(type0,K,npar){
# initialize chains. the last column is for likelihood
  set.seed(2025)
chain_int = matrix(nrow = K, ncol = npar+1)
chain_list = list()
theta_0 = chain_int
  if(length(zeta_index)!=0){
    theta_0[,zeta_index] = runif(K*length(zeta_index), min = -50, max = 50)
    theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 100)
  }else{
    theta_0[,-c(npar+1)] = runif(K*npar, min = 0, max = 100)
  }

  theta_0[,(npar-1)] = runif(K, min = 0 , max = 5)

theta_0[,(npar+1)] = sapply(1:K, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0) ))})

# check whether All Likelihood is smaller than Inf
index = which(is.infinite(theta_0[,(npar+1)]))

while (length(index)) {
  if(length(zeta_index)!=0){
  theta_0[index,zeta_index] = runif(length(index)*length(zeta_index), min =-100, max = 100) #100
  theta_0[index,-c(zeta_index,npar+1)] = runif(length(index)*(npar-length(zeta_index)), min = 0, max = 100)
   }else{
    theta_0[index,-c(npar+1)] = runif(length(index)*npar, min = 0, max = 100)
  }
  theta_0[index,(npar-1)] = runif(length(index), min = 0 , max = 5)
  

  theta_0[index,(npar+1)] = sapply(index, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0)))})
  index = which(is.infinite(theta_0[,(npar+1)]))

  # print(paste("Still has", length(index), "to find."))
}
chain_list[[1]] = theta_0

return(chain_list)
}

###########################################
# cross-over step
Update_para = function(para){
  # para = list(ChainIndex,last_chainlist,gamma)
  # last_chainlist is a matrix each row means the last step value of each chain and the last column is the liklihood of the corresponding parameters
 
  theta_prev = para$last_chain[para$ChainIndex,-(npar+1)]
  # randomly draw two chain from all chains except current chain
  de_ChainIndex = sample(probset[-para$ChainIndex], size = 2,replace = FALSE)
  theta_m = para$last_chain[de_ChainIndex[1],-(npar+1)] 
  theta_n = para$last_chain[de_ChainIndex[2],-(npar+1)] 
  # generate new theta, the here are 6 parameters to estimate in total
  add = runif(npar, min = -0.001, max = 0.001)
  theta_new = theta_prev + para$gamma* (theta_m - theta_n) + add
  
  new_post = poster(para_list = list(para = theta_new, type = type0) )
  prev_post = para$last_chain[para$ChainIndex,(npar+1)]

  # accept rate
  alpha = runif(1)
  
  ratio = exp(new_post-prev_post)
  #if(is.na(ratio)) ratio = 0
  if( alpha> ratio) temp = c(theta_prev,prev_post) else temp = c(theta_new,new_post)
    
  
  return(temp)
}
######################################### 
## update chains
De_MCMC_unit = function(prev, X, gam1){
  
  para = list(ChainIndex = X, last_chain = prev, gamma = gam1)#runif(1,.5,1)
  Update_para(para)
}

#########################################
# migrate step
migrate_step = function(current_chain_list){
    temp_ssize = ceiling(runif(1,min = 1, max = K))
    temp_sample =sample(1:K,temp_ssize,replace = FALSE)
    
    theta_res = current_chain_list[temp_sample[1],]
    for (g in 1:temp_ssize){
     temp_theta = current_chain_list[temp_sample[g],-(npar+1)]
     add = runif(npar, min = -0.01, max = 0.01)#npar
    
      if(g==1) new_theta = current_chain_list[temp_sample[temp_ssize],-(npar+1)] +add
     # previous item 
      else  new_theta = theta_res[-(npar+1)] + add
     
      new_post = poster(para_list = list(para = new_theta, type = type0))
      prev_post = theta_res[(npar+1)]
      theta_res = current_chain_list[temp_sample[g],]
      
      alpha = runif(1)
      ratio = exp(new_post-prev_post)
      #if(is.na(ratio)) ratio = 0
      if(alpha<ratio)  current_chain_list[temp_sample[g],] = c(new_theta,new_post)
    }
    
    return(current_chain_list)
}
###########################################
# parall_computing

demcmc_fun = function(chain_list, burn_in, M, mig_rate, type0, probset, K, N, npar, RC, RT, attrs,version,continuous = 0,df_type){
  
for (j in (1+continuous):(M+continuous)) {

  chain_list[[j+1]] = t(parSapply(X = 1:K, FUN = De_MCMC_unit, prev = chain_list[[j]], gam1 = gam, cl = cl))
  
  # immigration step (only works at certain steps at early stage)
  if ((j<round(continuous+burn_in*0.75))&(runif(1)<mig_rate)){
chain_list[[j+1]] = migrate_step(current_chain_list = chain_list[[j+1]])}
  if(type0=="CO"){
    if(j%%1e2==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  else{
    if(j%%1e3==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  
  if(j%%1000==0) {saveRDS(chain_list, file = paste0("chain_list_",type0,"_",df_type,"(",npar,")_",N,version,".rds",sep=""))}
  } 
  
return(list(chain_list=chain_list,path = paste0("chain_list_",type0,"_",df_type,"(",npar,")_",N,version,".rds",sep="")))
}
########################################
# result generation
result_fun = function(type0, N, attrs,version,df_type){
  set.seed(2024)
  path = paste0("chain_list_",type0,"_",df_type,"(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) 
  
  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
  }
  
  
  
  post_mean = apply(post,1, mean)
  post_mean[npar+1] = poster(para_list = list(para = post_mean[-(npar+1)],type = type0))
  if(length(zeta_index)!=0){post_mean[zeta_index] = post_mean[zeta_index]+true_param$zeta[3]}
    
  post_median = apply(post , 1, median)
  post_median[npar+1] = poster(para_list = list(para = post_median[-(npar+1)],type = type0))
  if(length(zeta_index)!=0){
    post_median[zeta_index] = post_median[zeta_index]+true_param$zeta[3]
    post[zeta_index,] = post[zeta_index,]+true_param$zeta[3]
    Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]}
  
name = c("betaTC","betaDR","zetaICEV", "lam1", "b","Lik")
  
  HDI_para = apply(post, 1,function(x){temp = hdi(x, ci = 0.95, verbose = FALSE); return (c(temp$CI_low, temp$CI_high))},simplify = TRUE)
  MLE_value[zeta_index] = MLE_value[zeta_index]+true_param$zeta[3]
  result4 = data.frame( #true =true_value,
                        est_mean = round(post_mean,3),
                        est_median = round(post_median,3), 
                        sd = round(post_sd,3),
                        hdi_95 = c(sapply(1:npar, function(x){paste("( ", round(t(HDI_para)[x,1],3),", ",round(t(HDI_para)[x,2],3),")")}),"-"),
                        #mse = round(post_mse,3),
                        MLE = round(est_MLE[MLE_index,],3))
                        
  post_app = rep(NULL,npar+1)
  rownames(result4) = name
  write.csv(post,paste("Post_",df_type,"_",N,"_",type0,"Aug_",version, ".csv",sep=""))
  return(result4)
  write.csv(result4,paste0(type0,"_post_",df_type,"_",N,version,".rds",".csv",step = ""))
}


```

## 2.3 MLE setup
```{r}
library(optimParallel)
##############################
# likelihood function
LL = function(para,type0){
  temp = poster(para_list = list(para = para, type0 = type0))#-log(1/200)*(npar-2)-log(1/5)*2
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}

gn = function(para,type0){
  para_list = para_fun(para = para)
 if(type0=="CRT"){
   temp = score_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = score_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = score_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
  # temp = numDeriv::grad(func = LL1,x = para)
  # temp = temp[-(nAttr+nAlt-1+2-1)]
  for(tempi in 1:length(temp)){
    if(is.na(temp[tempi])) temp[tempi] = 0
  if(is.infinite(temp[tempi])) {
    if(temp[tempi]>0) {temp[tempi] = 1e6}
    else {temp[tempi] = -1e6}
  }
    }
  return(temp)
}

gnBHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = t(sapply(1:N, function(x){score_mlba_crt_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else if (type0 == "RTG"){
   temp = t(sapply(1:N, function(x){score_mlba_rtg_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else{
   temp = t(sapply(1:N, function(x){score_mlba_co_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x])}))
 }
  return(temp)
}

Hessian_BHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = derivative_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = derivative_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = derivative_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
 for(tmpi in 1:dim(temp)[1]){
   for(tmpj in 1:dim(temp)[2]){
     if(is.na(temp[tmpi,tmpj])) temp[tmpi,tmpj] = 0
     else if (is.infinite(temp[tmpi,tmpj])) {
       if(temp[tmpi,tmpj>0]) temp[tmpi,tmpj]=1e6
       else temp[tmpi,tmpj]=-1e6
     }
     
     }}
 
  return(temp)
}
#########################
mle_fun = function(type0, N, attrs, npar, RC, RT, try_times, MAP_value,Mean_value,Median_value,L_vec,cl,pgtol,version,df_type){
  # set up mle
  set.seed(2025)
  est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = try_times)
  mle1_list_adj_v1 = list()
  mle1_list_sd_v1 = list()
  i = 1;k = 1
 
  while(i<=try_times){
      if(k==1){
        par_value = MAP_value
      }
      else if(k==2) {
        par_value = Mean_value
      }
    else if(k==3) {
        par_value = Median_value
      }
      else {
      tmp_alpha = runif(1)
      tmpt_value = ifelse(tmp_alpha<0.5,ifelse(tmp_alpha<0.2,Mean_value,Median_value),MAP_value)
      tmpt_value = MAP_value
      if(k<50){
        
       noise = runif(npar,min = -1,max = 1)
      noise[(npar-1)] =  runif(1,min = - 0.1,max = 0.1) 
      }else if (k<100){
        if(k==51) message("has tried 50 different initial values.")
        noise = runif(npar,min = -5,max = 5)
      noise[(npar-1)] =  runif(1,min = - 0.5,max = 0.5) 
      }else{
        if(k==101) message("has tried 100 different initial values.")
        noise = runif(npar,min = -10,max = 10)
      noise[(npar-1)] =  runif(1,min = - 1,max = 1) 
      }
      
      
      par_value = tmpt_value + noise  
      if(length(zeta_index)!=0){
        par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(max(x,0))})
      par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(min(x,200))})
      }
      else{
        par_value = sapply(par_value,function(x){return(max(x,0))})
      par_value = sapply(par_value,function(x){return(min(x,200))})
      }
      par_value[c(npar-2,npar-1)] = sapply(par_value[c(npar-2,npar-1)],function(x){return(max(x,0))})
      par_value[c(npar-2,npar-1)] = sapply(par_value[c(npar-2,npar-1)],function(x){return(min(x,5))})
      
      
    }
  OK = tryCatch(
    { k = k+1
      mle1 = optimParallel(par = par_value,
      fn = LL1, gr = gn1, 
      method = "L-BFGS-B",
      lower = c(0,0,-100,0,0), #5
      upper = c(200,200,100,5,200), #5
      control = list(fnscale = -1,#maxit = 1e4,
                     # ndeps = c(1e-3,1e-3,1e-3,1e-3,1e-3),
                     #pgtol = pgtol,
                     trace = 0),
      # hessian = ifelse(type0=="CO",TRUE,FALSE),
        # TRUE,
                     #pgtol = 1e-3*npar),
      parallel = list(cl=cl))
if(k==2){message(paste("The MLE estimation of ",type0," with " ,N, " has started:",sep=""))
  # message(mle1)
  }
if(is.na(mle1$convergence)) {FALSE}
else{
  if (mle1$convergence!= 0) {FALSE}
else{
    w_matrix = L_vec%*%Hessian_BHHH(para = as.numeric(mle1$par),type0 = type0)%*%t(L_vec)
  if(det(w_matrix)==0){
    flag = 0
   
  }else{
    sd.hat = tryCatch(sqrt(diag(solve(-w_matrix))),error =function(e) {NA},warning =function(w){NA} )  #
 
    flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat)))
    
  }
   
  if(flag){
    mle1_list_adj_v1[[i]] = mle1 
    mle1_list_sd_v1[[i]] = sd.hat
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    
    TRUE
    }else{FALSE}
    
    }
}

    },
  error=function(e){return(FALSE)})
  if (OK){
    if (type0=="CO"){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
      if(i%%5==0){
        saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))
      }}
    else if (i%%3 ==0){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
    }
  
    i = i+1 } else {next}
  
  if(k==250){
    message("200 attempts have been made. quite the process now")
  break}
  }

  
  
  saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep=""))

  }
#########################

#######################
result_mle_fun = function( type0, N, attrs, npar, RC, RT,try_times,L_vec,pgtol,version,df_type){

  est_mle1_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_est_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_object_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_sd_v1 = readRDS(file =  paste(type0,"(",npar,")","_sd_",df_type,"_MLE",try_times,"Aug_",N,version,".rds",sep = ""))

# tol_check = sapply(1:try_times,function(tryi){tmp = max(gn1(est_mle1_adj_v1[-(npar+1),tryi])/N);ifelse(tmp<=pgtol,1,Inf)})

tol_check = rep(1,try_times)


index = which.max(est_mle1_adj_v1[(npar+1),]*tol_check)
crt_para = est_mle1_adj_v1[,index]
if(length(zeta_index)!=0){
  crt_para[zeta_index] = crt_para[zeta_index]+true_param$zeta[nAlt]
}

crt_mle = mle1_list_adj_v1[[index]]
crt_mle_value = crt_para
res_mle = data.frame(est =round(crt_para,3),se = c(round(mle1_list_sd_v1[[index]],3),"-"),gr =c( gn1(est_mle1_adj_v1[-(npar+1),index])/N,"-"),eigen_value = round(c(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value,max(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index], type0 = type0)%*%t(L_vec)))$value)/min(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value)),3))
return(res_mle)
}

```


# 3. MLBA Estimation

## 3.1 Bayesian estimation by De-MCMC
```{r}
sample_size = nrow(df)
type_set = c("CRT")#,"RTG"
version = "v1";df_type = "em1"
K = 27; M =1e4; burn_in = 4e3;mig_rate = 0.35; gam = 2.38/sqrt(2*npar);probset = 1:K 
######### NOTE ################
#  CTG: mig_rate = 0.35;
#  RTG: mig_rate = 0.15;
############################### parallel computing setup
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
numCores = min(K,detectCores()-2)
# use enough cores to do parallel computation ,but not overload CPU
cl = makeCluster(numCores) 
# settings for parallel computing
clusterEvalQ(cl=cl, {library("doParallel");library("parallel");library("foreach");library("Rcpp");library("RcppArmadillo");library("truncnorm");library("RcppNumerical")})

clusterExport(cl = cl, c("file_route","true_param", "De_MCMC_unit", "poster", "Update_para", "K","gam", "npar",  "nAlt", "zeta_index" ,"nAttr", "para_fun", "migrate_step","probset"), envir = .GlobalEnv) 
clusterEvalQ(cl=cl, sourceCpp(file_route))

########################################
m = 1
for (type0 in type_set){

    basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
    
clusterExport(cl = cl, c("N", "RT", "RC", "type0","attrs"), envir = .GlobalEnv)

# initual a fresh estimation
chain_list = chain_intial(type0=type0, K = K,npar = npar);continuous = 0

# resume an estimation with more iterations; then set continuous = M
# chain_list = readRDS(file = paste0("chain_list_",type0,"_",df_type,"(",npar,")_",N,version,".rds",sep=""));continuous = 0

chain_list = demcmc_fun(chain_list = chain_list, burn_in = burn_in,
                        mig_rate = mig_rate, type0 = type0, K = K, N=N,
                        npar = npar,RC = RC, RT = RT, attrs = attrs,probset = probset,M = M, version = version,continuous = continuous,df_type = df_type)
toc()
    
    m = m+1
  }


stopCluster(cl=cl);doParallel::stopImplicitCluster()
# CRT for 596 observations simulation takes:: 60.31 sec elapsed
# RTG for 596 observations simulation takes:: 179.7 sec elapsed

```


```{r}
sample_size = nrow(df)
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
result_table = list()

m=1
for (type0 in type_set){
    
    basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

    result_table[[m]] = result_fun(type0 = type0,N = N, attrs = attrs,version = version,df_type = df_type)
    print(paste(N, "of MLBA",type0,"result has been printed.",sep = " "))
    m = m+1
  }

result_table[[1]];result_table[[2]]
saveRDS(result_table,paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))



# result_table = readRDS(paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))


```



## 3.2. MLE estimation
```{r}
sample_size = nrow(df)
type_set = c("CRT","RTG") 
version = "v1";df_type = "em1"

try_times = 30; max_index = nAttr+nAlt-1+2+1; L_vec = diag(0,nrow = npar,ncol = max_index); diag(L_vec[,-c((nAttr+2):(nAttr+nAlt-1),nAttr+nAlt+1)]) = 1;pgtol = 1e-3;

#####################
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
# parallel estimation set up
numCores = detectCores()-1
# numCores = min(1+2*npar,detectCores()-2)  
# set the number of processor cores
cl = parallel::makeCluster(numCores) 
parallel::clusterEvalQ(cl, {
  # Optional: keep each worker single-threaded to avoid nested threading
  Sys.setenv(OMP_NUM_THREADS="1", OPENBLAS_NUM_THREADS="1", MKL_NUM_THREADS="1",
             VECLIB_MAXIMUM_THREADS="1", NUMEXPR_NUM_THREADS="1")
  if (requireNamespace("RhpcBLASctl", quietly = TRUE)) {
    RhpcBLASctl::blas_set_num_threads(1)
    RhpcBLASctl::omp_set_num_threads(1)
  }
  NULL
})

parallel::clusterEvalQ(cl = cl, {library(Rcpp); library(RcppArmadillo); library(truncnorm); library(RcppNumerical); library(numDeriv);})
clusterExport(cl = cl, c("file_route","true_param", "npar",  "nAlt","zeta_index" ,"nAttr", "df", "LL","gn","poster","para_fun","L_vec","max_index"), envir = .GlobalEnv)
clusterEvalQ(cl = cl, sourceCpp(file_route))
message("The parallel setting has been done.")
#####################
  

result_table = readRDS(file = paste("Result_table_bayesian_",df_type,"_",version,".rds",sep = "") )
mle_res_table = list()

m = 1
for(type0 in type_set){

    basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
  LL1 = function(para) LL(para = para, type0 = type0)
gn1 = function(para) L_vec %*% gn(para = para, type0 = type0)
  MAP_value = result_table[[m]]$MLE[-(npar+1)]
  Mean_value =result_table[[m]]$est_mean[-(npar+1)]
  Median_value =result_table[[m]]$est_median[-(npar+1)]
  if(length(zeta_index)!=0){
    MAP_value[zeta_index] = MAP_value[zeta_index]-true_param$zeta[nAlt]
    Mean_value[zeta_index] = Mean_value[zeta_index]-true_param$zeta[nAlt]
    Median_value[zeta_index] = Median_value[zeta_index]-true_param$zeta[nAlt]
  }

  parallel::clusterExport(cl = cl,
  c("type0","N","attrs","RC","RT","MAP_value","LL1","gn1"),envir = environment())

  mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, MAP_value = MAP_value,Mean_value = Mean_value,Median_value = Median_value, L_vec = L_vec, cl = cl, pgtol = pgtol,version = version,df_type = df_type)
  toc()

  m = m+1
  }
  
  
  


stopCluster(cl=cl);doParallel::stopImplicitCluster()
# CRT for 596 observations simulation takes:: 17.93 sec elapsed
# RTG for 596 observations simulation takes:: 188.86 sec elapsed
```

```{r}
sample_size = nrow(df)
type_set = c("CRT","RTG")
try_times = 30; max_index = nAttr+nAlt-1+2+1;L_vec = diag(0,nrow = npar,ncol = max_index); diag(L_vec[,-c((nAttr+2):(nAttr+nAlt-1),nAttr+nAlt+1)]) = 1;pgtol = 1e-2;
version = "v1"
result_table = readRDS(file = paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))
mle_res_table = list()
m=1

for (type0 in type_set){
    basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    LL1 = function(para){
    return(LL(para = para,type0 = type0))
  }
    gn1 = function(para){
      temp = gn(para = para,type0 = type0)
      res =  L_vec%*%temp 
    return(res)
    }

mle_res_table[[m]] = result_mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, L_vec = L_vec, pgtol = pgtol,version = version,df_type = df_type)
m = m+1
  }


saveRDS(mle_res_table,paste("Result_table_mle_",df_type,"_",version,".rds",sep=""))
mle_res_table[[1]];mle_res_table[[2]]

```

# 4. Accuracy Calculation
```{r}
acc= function(para,type0,RC,RT,attrs,N){
  prob = NULL
  for (j in 1:nAlt){
  para_list = para_fun(para = para)
  if(type0=="CRT"){
    # temp = MLBA_rtknown_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N), rt = RT)
    # temp = MLBA_rtg_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N), rt = RT)
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))
    
  }else if(type0=="RTG"){
    temp = MLBA_rtg_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N), rt = RT)
  }else{
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))}
  prob = cbind(prob,temp)
  }
  prob = t(apply(prob,1,function(x){x/sum(x)}))
  tmp = matrix(0,ncol = nAlt, nrow = N)
  for( i in 1:N){
    tmp[i,RC[i]] = 1
  }

  brier = sum((tmp-prob)**2)/N 
    
  discard = which((prob[,1]==prob[,2])|(prob[,3]==prob[,2])|(prob[,1]==prob[,3]))
  #discard = integer(0)
  if(length(discard)==0) {chosen_est = apply(prob, 1, which.max)

  acc = sum(chosen_est==RC)/N*100}
  else{
    chosen_est = rep(-1,dim(prob)[1])
    chosen_est[-discard] = apply(prob[-discard,], 1, which.max)

    acc = sum(chosen_est[-discard]==RC[-discard])/(N-length(discard))*100
  }
  
  
  
  
  
  return(list(acc = round(acc,1),brier = round(brier,3),dis = length(discard)))

}
```

```{r}
# acc table generation
sample_size = nrow(df_raw)
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
result_table = readRDS(file = paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))
result_mle_table = readRDS(file = paste("Result_table_mle_",df_type,"_",version,".rds",sep=""))



# training set
basic_Info = df_info(df = df_raw)
N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
m=1
# acc
mean_b_crt = result_table[[(m-1)*length(type_set)+1]]$est_mean[-(npar+1)]
mle_crt = result_mle_table[[(m-1)*length(type_set)+1]]$est[-(npar+1)]
mean_b_rtg = result_table[[(m-1)*length(type_set)+2]]$est_mean[-(npar+1)]
mle_rtg = result_mle_table[[(m-1)*length(type_set)+2]]$est[-(npar+1)]

if(length(zeta_index)!=0){
  
mean_b_crt[zeta_index] = mean_b_crt[zeta_index]-true_param$zeta[nAlt]
mle_crt[zeta_index] = mle_crt[zeta_index]-true_param$zeta[nAlt]

mean_b_rtg[zeta_index] = mean_b_rtg[zeta_index]-true_param$zeta[nAlt]
mle_rtg[zeta_index] = mle_rtg[zeta_index]-true_param$zeta[nAlt]

}


acc_table = data.frame(size = rep(sample_size,length(type_set)),
                                    models = type_set,
                                    acc_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,
                                                 acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc),
                                    acc_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc)
                       )

# brier
brier_table  = data.frame(size = rep(sample_size,length(type_set)),
                                      models = type_set,
                                      brier_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier),
                                    brier_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier)
                          )  
    


saveRDS(acc_table,paste("acc_table_",df_type,"_",version,".rds",sep=""))
saveRDS(brier_table,paste("brier_table_",df_type,"_",version,".rds",sep=""))


print(acc_table);print(brier_table)
```



# 5. Diagnosis Plots

## 5.1 Beyesian Diagnosis plots
```{r}
# trace plot to check whether the rest of chains are stable, sample size = 1e3
library(ggpubr)
library(ggplot2)
diagnosis_Bayesian_fun = function(type0, N, attrs,version,df_type){
  set.seed(2025)
  path = paste0("chain_list_",type0,"_",df_type,"(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) #RTG 200

  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  if(length(zeta_index)!=0){
    MLE_value[zeta_index] = MLE_value[zeta_index]+true_param$zeta[nAlt]
  }
  
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  Supper_chain_sd = sapply(chain_all, function(x){apply(x,2,sd)})

  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
  }
  if(length(zeta_index)!=0){
  Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]}
  # post_median = apply(post , 1, median)
  # post_median[npar+1] = poster(para_list = list(para = post_median[-(npar+1)],type = type0))
  
  name1 = c(bquote(beta[TC]~", "~.(type0)), 
            bquote(beta[DR]~", "~.(type0)), 
            bquote(zeta[ICEV]~", "~.(type0)),
            bquote(lambda[1]~", "~.(type0)),
            bquote(b~", "~.(type0)),bquote("Posterior"~", "~.(type0)))
  
  plt = list()
  plt$sdplt = list()
  plt$traceplt = list()
  for( i in 1:(npar+1)){
    plt_df = data.frame(value = matrix(t(Supper_chain[,,i]),ncol = 1),chain = factor(matrix(t(replicate(length(thin),1:K)),ncol = 1)),iter = matrix(replicate(K,1:length(thin)),ncol = 1))
    plt$traceplt[[i]] = ggplot()+ 
      geom_line(data =plt_df, aes(x=iter, y=value, colour = chain),alpha = 0.5)+ 
      guides(color = "none")+
      theme_classic()+
      labs(subtitle = name1[[i]])+
      geom_hline(yintercept = MLE_value[i],color = "red", linewidth = 1.5, alpha = 0.7, linetype = 2)
    plt$sdplt[[i]] = ggplot()+
      geom_line(data =data.frame(sd = Supper_chain_sd[i,],iter = 1:length(Supper_chain_sd[i,])), aes(x=iter, y=sd),alpha = 0.5)+
      theme_classic()+
      labs(subtitle =name1[[i]])
    
  }
  
  plt$traceplt[[npar+2]] = ggarrange(plotlist = plt$traceplt,nrow = 3,ncol = 2)
  plt$sdplt[[npar+2]] = ggarrange(plotlist = plt$sdplt,nrow = 3,ncol = 2)
  
  return(plt)
}



```

```{r}
sample_size = nrow(df_raw)
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
plt_b = list()

m=1
for (type0 in type_set){
basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
plt_b[[m]] = diagnosis_Bayesian_fun(type0=type0, N=N, attrs=attrs,version=version,df_type = df_type)
    m = m +1
    }
  

saveRDS(plt_b,file = paste("Diagnosis_plt_beyesian_",df_type,"_",version,".rds",sep=""))

```

```{r}
m= 1;plt_b[[m]]$sdplt[[npar+2]];plt_b[[m]]$traceplt[[npar+2]]
############## save plt pdf

sample_size = nrow(df)
type_set = c("CRT","RTG") 
version = "v1";df_type = "em1"
m=1

for (type0 in type_set){
    ggsave(paste("Diagnosis_sim_trace_",df_type,"_",type0,"_" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$traceplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

    ggsave(paste("Diagnosis_sim_sd_",df_type,"_",type0,"_" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$sdplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

   m = m+1
  }



```


## 5.2 MLE checkplots 



```{r}

diagnosis_MLE_fun = function(type0, N, attrs,version,res_table){

name1 = c(bquote(beta[-TC]~", "~.(type0)~"( "~")"), 
            bquote(beta[DR]~", "~.(type0)~"( "~")"), 
            bquote(zeta[ICEV]~", "~.(type0)~"( "~")"),
            bquote(lambda[1]~", "~.(type0)~"( "~")"),
            bquote(b~", "~.(type0)~"( "~")"))


low = res_table$est[-(npar+1)]-as.numeric(res_table$se[-(npar+1)])*1.96-1
upper = res_table$est[-(npar+1)]+as.numeric(res_table$se[-(npar+1)])*1.96+1

if(length(zeta_index)!=0){
  low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){max(0,x)})
low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){min(200,x)})

upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){max(0,x)})
upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){min(200,x)})
}
low = sapply(low,function(x){max(0,x)})
low = sapply(low,function(x){min(200,x)})

upper = sapply(upper,function(x){max(0,x)})
upper = sapply(upper,function(x){min(200,x)})

low[c(npar-1)] = sapply(low[c(npar-1)],function(x){min(0,x)})
upper[c(npar-1)] = sapply(upper[c(npar-1)],function(x){min(5,x)})

plot = list()
for(i in 1:npar){
value_seq = sort(c(res_table$est[i],seq(from = low[i], to =upper[i], length.out =50)))
#MLE_value
LLK_seq = sapply(value_seq, function(x) {tmp = res_table$est[-(npar+1)];if(length(zeta_index)!=0){tmp[zeta_index] = tmp[zeta_index]-true_param$zeta[nAlt];}
tmp[i] =x; return(LL(para = tmp, type0 = type0))})
plot[[i]] = ggplot(data = data.frame(value = value_seq,llk = LLK_seq))+geom_line(aes(x = value, y = llk))+labs(title = name1[[i]])+
  geom_vline(aes_(xintercept =res_table$est[i],color = "mle"))+
  scale_color_discrete(type = c("mle" = "blue"))
}

plot[[npar+1]] = ggarrange(plotlist = plot,nrow = 2,ncol = 3,common.legend = T)

return(plot)
}

```

```{r}
mle_res_table = readRDS(paste("Result_table_mle_",df_type,"_",version,".rds",sep=""))
sample_size =nrow(df_raw)/nAlt
type_set = c("CRT","RTG") 
version = "v1";type_df = "em1"
plt_mle = list()

m=1

for (type0 in type_set){
basic_Info = df_info(df = df_raw)
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

plt_mle[[m]] = diagnosis_MLE_fun(type0 = type0, N = N, attrs = attrs,version = version,res_table =mle_res_table[[m]])
    m = m +1
    }
  


saveRDS(plt_mle,file = paste("Diagnosis_plt_mle_",df_type,"_",version,".rds",sep=""))


```

```{r}
m=1;plt_mle[[m]][[npar+1]]

############## save plt pdf

sample_size = nrow(df_raw)/nAlt
type_set = c("CRT","RTG") 
version = "v1";df_type = "em1"
m=1

for (type0 in type_set){
    ggsave(paste("Diagnosis_sim_MLE_",df_type,"_",type0,"_","_",version,".pdf",sep=""),
         plot   = plt_mle[[m]][[npar+1]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")
   m = m+1
  }


```





# 6. RUM check
```{r}
library(gmnl)
library(mlogit)
library(readr)
```


```{r}

df_long = data.frame(attrs,EV = sapply(df_raw$alt,function(x){if (x%in%c(3,4)) return(0) else return(1)}),Alt = rep(1:3,N),chosen = df_raw$chosen)
colnames(df_long) = c("(neg)TC","DR","ICEV?","Alt","chosen")
head(df_long)

```

```{r}
df_mnl = mlogit.data(df_long, choice = "chosen", shape = "long", alt.levels = c("3","1","2"),alt.var = "Alt")

m1.t = gmnl(chosen~`(neg)TC`+DR+`ICEV?`|0|0, data = df_mnl)

summary(m1.t); BIC(m1.t)

```

```{r}
MNL_prob = m1.t$prob.alt
tmp = MNL_prob[,1]
MNL_prob[,1:2] = MNL_prob[,2:3]
MNL_prob[,3] = tmp
MNL_c = apply(MNL_prob,1,which.max)

basic_Info = df_info(df = df_raw)
N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
acc = sum(MNL_c==RC)/length(RC)*100

tmp = matrix(0,ncol = nAlt, nrow = length(RC))
for( i in 1:N){tmp[i,RC[i]] = 1}
brier = mean((tmp-MNL_prob)^2)*nAlt

c(acc,brier)  #  67.785235  0.483987
```


# 7. fitness plots
## 7.1 PP df 
```{r}
# p-p plot by scenarios
library(tidyr)
library(dplyr)

type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
result_table = readRDS(file = paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))

df_pp_list = list()
df_new = data.frame(df_raw[,1:4], TC = attrs[,1],DR = attrs[,2],rt = df_raw$rt,chosen = df_raw$chosen)
real_p = df_new%>% group_by(Scenario) %>%nest()

m=1
for(type in type_set){
  est_para1 = result_table[[m]]$est_median[-(npar+1)]
  est_para1[zeta_index] = est_para1[zeta_index]-true_param$zeta[nAlt]
  
  df_pp = data.frame(Scenario = NULL, real_prob = NULL,Alt = NULL, est_prob = NULL, RST_real = NULL, RST_est = NULL)
  for(i in 1:length(real_p$Scenario)){
    
  data_tmp =real_p$data[[i]]
  temp_chosen = matrix(data_tmp$chosen,nrow = nAlt) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))
  para = para_fun(para = est_para1)
  est_prob = sapply(1:nAlt, function(x){
  if(type =="CRT"){
    
    
    MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else if (type  =="RTG"){
    MLBA_rtg_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else{
   RCPPcdf_MLBA_CO_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID)))) 
  }  
    })
  quantile_est = colMeans(est_prob)/sum(colMeans(est_prob))
  
  #quantile_est = colMeans(est_prob)
  df_tmp = data.frame(Scenario = rep(str_sub(real_p$Scenario[i],start = 1,end = 4),nAlt),real_prob = Prob_real, Alt = c("competitor","target", "decoy" ), est_prob =  quantile_est, RST_real=rep(Prob_real[2]/(Prob_real[2]+quantile_est[1]),3),RST_est = rep(quantile_est[2]/(quantile_est[2]+quantile_est[1]), 3))
  
  df_pp = rbind(df_pp,df_tmp)
  
  }
  
  df_pp$Scenario[which(df_pp$Scenario=="A1.1")] = "A1"
  df_pp$Scenario[which(df_pp$Scenario=="A1.2")] = "A2"
  df_pp$Scenario[which(df_pp$Scenario=="A1.3")] = "A3"
  df_pp$Scenario[which(df_pp$Scenario=="A1.4")] = "A4"
  
  df_pp$R_square = cor(df_pp$real_prob,df_pp$est_prob, method = "pearson")^2
  
  df_pp_list[[m]] = df_pp
  m = m+1
}

# saveRDS(df_pp_list,file = paste("PP_df_",df_type,"_",version,".rds",sep=""))

df_pp_list[[1]];df_pp_list[[2]]

```


## 7.2 PP plots

```{r}
plt2 = list()
```


```{r}
df_pp_list = readRDS(paste("PP_df_",df_type,"_",version,".rds",sep=""))
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
plt2 = list()
plt2$pp = list()
m = 1
for (type in type_set){
  df_pp = df_pp_list[[m]]
  plt2$pp[[m]] = 
  ggplot(data = df_pp)+geom_point(aes(x =real_prob, y = est_prob,shape = Scenario, color = Alt),size = 3,alpha = 0.8)+
    scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))+
    #scale_shape_manual(values = c(21,22,23,24))+
    geom_abline(aes(intercept = 0, slope = 1))+
    labs(title = bquote(.(type)~": "~R^2~" = "~.(round(df_pp$R_square,3))),
           #paste(type,": ","R square", "=",round(df_pp$R_square,3)) 
           #beta[-TC]~", "~.(type0)~"( "~.(sample_size)~")")
         x = "Observed Proportion", y = "Estimated Proportion")+
    theme_classic()+
    coord_cartesian(xlim = c(0,0.65),ylim = c(0,0.65))+
     theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_text(size= 12),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")
  
  if(m==1){
    plt2$pp[[m]] = plt2$pp[[m]] +labs(x = "")
  }
  m = m+1
}

```


```{r}
# concate a mixture plots
plt2$mix = list()

plt2$mix[[1]] = ggarrange(plotlist = plt2$pp,nrow = 2,ncol = 1, common.legend = T,legend = "right")
plt2$mix[[1]]
```

## 7.3 counterfactural fitness df 


```{r}
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
result_table = readRDS(file = paste("Result_table_bayesian_",df_type,"_",version,".rds",sep=""))

df_cf_list = list()
df_new = data.frame(df_raw[,1:4], TC = attrs[,1],DR = attrs[,2],rt = df_raw$rt,chosen = df_raw$chosen)
# merge two senarios
df_new$Scenario[which(df_new$Scenario=="A1.4R")] = "A4"
df_new$Scenario[which(df_new$Scenario=="A1.3R")] = "A3"
df_new$Scenario[which(df_new$Scenario=="A1.2R")] = "A2"
df_new$Scenario[which(df_new$Scenario=="A1.1R")] = "A1"
df_new$Scenario[which(df_new$Scenario=="A1.4")] = "A4"
df_new$Scenario[which(df_new$Scenario=="A1.3")] = "A3"
df_new$Scenario[which(df_new$Scenario=="A1.2")] = "A2"
df_new$Scenario[which(df_new$Scenario=="A1.1")] = "A1"

real_p = df_new%>% group_by(Scenario) %>%nest()

m=1
for(type in type_set){
  est_para1 = result_table[[m]]$est_median[-(npar+1)]
  est_para1[zeta_index] = est_para1[zeta_index]-true_param$zeta[nAlt]
  
  df_cf = data.frame(Scenario = NULL,RT_quantile = NULL,RST = NULL,P_C = NULL,P_T = NULL,P_D = NULL, type = NULL)
  for(i in 1:length(real_p$Scenario)){
    
  data_tmp =real_p$data[[i]]
  temp_chosen = matrix(data_tmp$chosen,nrow = nAlt) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))
  para = para_fun(para = est_para1)
  est_prob = sapply(1:nAlt, function(x){
  if(type =="CRT"){
    
    
    MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else if (type  =="RTG"){
    MLBA_rtg_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else{
   RCPPcdf_MLBA_CO_all(X = as.matrix(data_tmp[,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID)))) 
  }  
    })
  tc_index = seq(from = 3, to = dim(data_tmp)[1],by = nAlt)
  est_prob2 = sapply(1:2, function(x){
  if(type =="CRT"){
    MLBA_rtknown_all(X = as.matrix(data_tmp[-tc_index,c(4,5)]),beta = para$beta, zeta = para$zeta[-nAlt], lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else if (type  =="RTG"){
    MLBA_rtg_all(X = as.matrix(data_tmp[-tc_index,c(4,5)]),beta = para$beta, zeta = para$zeta[-nAlt], lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])
  }
  else{
   RCPPcdf_MLBA_CO_all(X = as.matrix(data_tmp[-tc_index,c(4,5)]),beta = para$beta, zeta = para$zeta, lam1 =para$lam1, lam2 = para$lam2,  b = para$b, A =  para$A, s = para$s0, choice =rep(x,length(unique(data_tmp$ID)))) 
  }  
    })
  
  rt_quantile = quantile(t(matrix(data_tmp$rt,nrow = 3))[,1],prob = c(0,0.25,0.5,0.75))
 
  index = sapply(t(matrix(data_tmp$rt,nrow = 3))[,1],function(x){sum(x>=rt_quantile)})
  rst_real = rep(0,4)
  C_real = rep(0,4)
  T_real = rep(0,4)
  D_real = rep(0,4)
  
  rst_est = rep(0,4)
  C_est = rep(0,4)
  T_est = rep(0,4)
  D_est = rep(0,4)
  rst_binary = rep(0,4)
  C_binary = rep(0,4)
  T_binary = rep(0,4)
  D_binary = rep(0,4)
  for(j in 1:4){
    Prob_real = rowSums(temp_chosen[,which(index==j)])/sum(rowSums(temp_chosen[,which(index==j)]))
    rst_real[j] = Prob_real[2]/(Prob_real[1]+Prob_real[2])
    C_real[j] = Prob_real[1]
    T_real[j] =Prob_real[2]
    D_real[j] =Prob_real[3]
    quantile_est = colMeans(est_prob[which(index==j),])/sum(colMeans(est_prob[which(index==j),]))
    
    rst_est[j] = quantile_est[2]/(quantile_est[1]+quantile_est[2])
    
    C_est[j] = quantile_est[1]
    T_est[j] = quantile_est[2]
    D_est[j] = quantile_est[3]
    quantile_est_counter = colMeans(est_prob2[which(index==j),])/sum(colMeans(est_prob2[which(index==j),]))
    rst_binary[j] = quantile_est_counter[2]/(quantile_est_counter[1]+quantile_est_counter[2])
    C_binary[j] = quantile_est_counter[1]
    T_binary[j] = quantile_est_counter[2]
  }
  
  df_tmp = data.frame(Scenario = rep(real_p$Scenario[i],4*3),
                      RT_quantile = rep(c(0.25,0.5,0.75,1),3),
                      RST=c(rst_real, rst_est,rst_binary),
                      P_C= c(C_real, C_est,C_binary),
                      P_T = c(T_real, T_est,T_binary)
                      ,P_D = c(D_real, D_est,D_binary),
                      type = c(rep("Obs",4),rep("Est",4),rep("CF",4)))
  
  df_cf = rbind(df_cf,df_tmp)}
  df_cf_list[[m]] = df_cf
  m = m+1 
  }

# saveRDS(df_cf_list,file = paste("CF_df_",df_type,"_",version,".rds",sep=""))

df_cf_list[[1]];df_cf_list[[2]]
```
## 7.4 counterfactural fitness plt 
```{r}
type_set = c("CRT","RTG")
version = "v1";df_type = "em1"
df_cf_list = readRDS(paste("CF_df_",df_type,"_",version,".rds",sep=""))
plt2$cf = list()
m = 1
for (type in type_set){
  df_cf = df_cf_list[[m]]
  plt2$cf[[m]] =list()
  plt2$cf[[m]][[1]] = ggplot()+
    geom_boxplot(data = df_cf,aes(x =factor(RT_quantile), y = P_C,fill = type),alpha = 0.6,outliers = F,width = 0.7)+#,shape = Scenario
    scale_fill_discrete(type = c("#42376a","#6d1950","#d48849"))+
    labs(title =paste0(type,": Competitor"),x = "RT quantile", y = "Proportion", color = "type")+
    theme_classic()+
    geom_hline(aes(yintercept = 0.5),linetype = 2)+
    coord_cartesian(ylim = c(0,0.65))

###################
  plt2$cf[[m]][[2]] = ggplot()+
  geom_boxplot(data = df_cf,aes(x =factor(RT_quantile), y = P_T,fill = type),alpha = 0.6,outliers = F,width = 0.7)+#,shape = Scenario
  scale_fill_discrete(type = c("#42376a","#6d1950","#d48849"))+
  labs(title =paste0(type,": Target"),x = "RT quantile", y = "Proportion", color = "type")+
  theme_classic()+
  geom_hline(aes(yintercept = 0.5),linetype = 2)+
    coord_cartesian(ylim = c(0,0.65))
  if(m==1){
    plt2$cf[[m]][[1]] = plt2$cf[[m]][[1]] +labs(x="")
    plt2$cf[[m]][[2]] = plt2$cf[[m]][[2]] +labs(x="",y="")
  }
  else{
    plt2$cf[[m]][[2]] = plt2$cf[[m]][[2]] +labs(y="")
  }
  m = m+1
}

```


```{r}
plt2$mix[[2]] = ggarrange(plotlist = list(plt2$cf[[1]][[1]],plt2$cf[[1]][[2]],plt2$cf[[2]][[1]],plt2$cf[[2]][[2]]),nrow = 2,ncol = 2, common.legend = T,legend = "top")

plt2$mix[[3]] = ggarrange(plotlist = list(plt2$mix[[1]],plt2$mix[[2]]),nrow = 1,ncol = 2, common.legend = F,widths = c(1,1))

# saveRDS(plt2,file = paste("Fitness_plt_beyesian_",df_type,"_",version,".rds",sep=""))

```


```{r}
df_type = "em1";version = "v1"
plt2 = readRDS(file = paste("Fitness_plt_beyesian_",df_type,"_",version,".rds",sep=""))

ggsave(paste("Fitness_plt_beyesian_",df_type,"_",version,".pdf",sep=""),
         plot   = plt2$mix[[3]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")
```

