---
title: "MLBARCRT EVs semi-simulated dataset under Hancock model"
author: "Xinwei Li\n li.xinwei@u.nus.edu"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
      highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

```

# Data import
```{r, echo=FALSE, message=FALSE,results='hide'}
library(tictoc)
library(doParallel)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
library(RcppNumerical)
library(plyr)
library(data.table)
library(readr)
library(crayon)
library(ggplot2)



#file_route = "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\MLBA.cpp"

file_route = "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\MLBA_H.cpp"




df = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0501_hancock.csv")
df_test = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0501_test.csv")


#true_param = list(beta = c(4,5.36,5),zeta = c(-1,2,1),lam1 = 0.8, lam2 = 0.5,b = 10,s0 = 1,A = 1.1,I0 = 0) 

#true_param = list( lam1 = 1, lam2 = 0.5, zeta = c(0.3,-0.5,1), beta = c(1,2,5), s0 = 1, b_A = 10, A = 1,I0 = 0)

true_param = list( lam1 = 1, lam2 = 0.5, zeta = c(0.3-1,-0.5-1,0), beta = c(1,2,5), s0 = 1, b_A = 10, A = 1,I0 = 1)
sourceCpp(file_route)


```


```{r}
head(df)
```


```{r}
N = nrow(df)
nAttr = 3
nAlt = 3

X_wide = df[,3:ncol(df)]

tmp = sapply(1:N, function(x){return(matrix(X_wide[x,]))})
tmp[,1:5]
X_long = t(matrix(tmp,nrow = nAttr,byrow =F))
head(X_long)
```

# CRT fitting with MLBA

```{r}

npar = (nAlt-1)+nAttr +2 +1+1

zeta_index =1:(nAlt+nAttr-1)
#zeta_index =4#(nAlt):(nAlt+nAttr-2)
RC = df$chosen
RT = df$RT
npar;zeta_index
```


```{r}


attrs = X_long 

# normalized attributes value to [0,1]
attrs = sapply(1:nAttr, function(x){(unlist(attrs[,x])-min(unlist(attrs[,x])))/(max(unlist((attrs[,x])))-min(unlist(attrs[,x])))})

head(attrs)

range(attrs)


```

## 2. Drift rate mean generation
# CRT generation


```{r}
library(truncnorm)
tic("generation speed")
#set.seed(23)
set.seed(2024)
# decision-boundary draw
bi = matrix(runif(N*nAlt,min =true_param$A*(true_param$b_A-1) , max = true_param$A*true_param$b_A),nrow = nAlt)
#bi = true_param$b+true_param$A-ki
# decision rate mean

di = sapply(1:N, function(x){matrix(sapply(1:nAlt,function(c){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),],beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2, choice = c)}),ncol = 1)})

#di = sapply(1:N, function(x){matrix(sapply(1:nAlt,function(c){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),],beta = true_param$beta, zeta = true_param$zeta,lam1 = true_param$lam1, lam2 = true_param$lam2, I0=true_param$I0,choice = c)}),ncol = 1)})

# decision rate draw (all is positive)
vi = apply(di, 2, function(x){rtruncnorm(1,a = 0,mean = x,sd = true_param$s0)})

# corresponding time
ti = bi/vi

# Response time generation
RT = apply(ti, 2, min)
# Response time generation
RC = apply(ti, 2, which.min)

summary(as.factor(RC))

summary(RT)

#RCPPMLBA_Lik_rtknown(attrs,beta =true_param$beta,zeta = true_param$zeta,lam1 = true_param$lam1,lam2 = true_param$lam2,b = (true_param$b+1)*true_param$A, s = true_param$s0, A =true_param$A, choice = RC, rt = RT,I0=true_param$I0)
RCPPMLBA_Lik_rtknown(attrs,beta =true_param$beta,zeta = true_param$zeta,lam1 = true_param$lam1,lam2 = true_param$lam2,b = true_param$b_A*true_param$A, s = true_param$s0, A =true_param$A, choice = RC, rt = RT)/N

RCPPMLBA_Lik_rtg(attrs,beta =true_param$beta,zeta = true_param$zeta,lam1 = true_param$lam1,lam2 = true_param$lam2,b = true_param$b_A*true_param$A, s = true_param$s0, A =true_param$A, choice = RC, rt = RT)/N
RCPPMLBA_Lik_CO(attrs,beta =true_param$beta,zeta = true_param$zeta,lam1 = true_param$lam1,lam2 = true_param$lam2,b = true_param$b_A*true_param$A, s = true_param$s0, A =true_param$A, choice = RC)/N
 #1   2   3 
# 15 276  81 
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#  1.094   4.652   8.434  14.240  15.745 196.588

 #16 308  48
min(di);max(di);mean(di)
```





# 3. De-MCMC estimation

```{r}
# function to return the log-posterior of given parameter
poster = function(para){
  #para = para_test
 
  prior = rep(-1,length(para))
  
  prior[zeta_index] = dunif(para[zeta_index], min = -100, max = 100,log = T)
  prior[-zeta_index] = dunif(para[-zeta_index], min = 0, max = 200,log = T)
  #prior[-zeta_index] = dunif(para[-zeta_index], min = -3, max = 7,log = T)
  prior[(npar-2):(npar-1)] = dunif(para[(npar-2):(npar-1)], min = 0, max = 5,log = T)
  #prior[(npar-1)] = dunif(para[(npar-1)], min = 0, max = 5,log = T)
  #prior[npar] = dunif(para[npar], min = 0, max = 1,log = T)
  #prior[zeta_index] = dunif(para[zeta_index], min = -50, max = 50,log = T)
  
  

################################################## CRT
  # CRT 8
  #temp = sum(prior) +  RCPPMLBA_Lik_rtknown(attrs,beta =para[1:(nAttr)], zeta = c( para[(nAttr+1):(nAlt+nAttr-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  temp = sum(prior) +  RCPPMLBA_Lik_rtknown(attrs,beta =para[1:(nAttr)], zeta = c( para[(nAttr+1):(npar-4)],0),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT,I0 = para[npar-3]) 
 
################################################## RTG 
  # RTG 8
  #temp = sum(prior) +  RCPPMLBA_Lik_rtg(X = attrs,beta =para[1:(nAttr)], zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)

  #temp = sum(prior) +  RCPPMLBA_Lik_rtg(X = attrs,beta =para[1:(nAttr)], zeta = c(para[zeta_index]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
################################################## CO
  # CO 8
  #temp = sum(prior) +  RCPPMLBA_Lik_CO(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC)
  # I0
  #temp = sum(prior) +  RCPPMLBA_Lik_rtknown(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-4)],0),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar]+true_param$A, s = true_param$s0, A =true_param$A, choice = df0$rc, rt = df0$rt,I0 = para[npar-3])
  

 
  if(is.na(temp)) temp = -Inf
  
  return (temp)
}
```


```{r}
para_test = c( true_param$beta,
              #true_param$beta[-1]/true_param$beta[1],
              true_param$zeta[-3]-true_param$zeta[3],
              true_param$I0,
              true_param$lam1,
              true_param$lam2,
              true_param$b_A*true_param$A)
#para_test = c(log(true_param$beta),#[-1]
#              true_param$zeta[-3]-true_param$zeta[3],
              #log(true_param$I0),
              #true_param$lam1,
#              true_param$lam1,
              #true_param$lam2,
#              true_param$lam2,#)
#              log(true_param$b))
poster(para_test)

# -0.1003522*N CO checked
# -606.0864 CRT checked
# -187.4211 RTG 
```

# MNL check
```{r}

library(gmnl)
library(mlogit)
library(readr)
```


```{r}
choice = function(c){
  #c is the index of chosen alternative
  
  tmp = matrix(0,nrow = nAlt, ncol = length(c))
  for( i in 1:N){
    tmp[c[i],i] = 1
  }
  return(matrix(tmp,ncol = 1))
}


df_long = data.frame(attrs,Alt = rep(1:3,N),chosen = X_wide$chosen,income = log(df_raw$income) )
colnames(df_long) = c("RC_scaled","OC_scaled","ln_DR_scaled","Alt","chosen","income")
head(df_long)

```

```{r}
df_mnl = mlogit.data(df_long, choice = "chosen", shape = "long", alt.levels = c("3","1","2"),alt.var = "Alt")

m1.t = gmnl(chosen~RC_scaled+OC_scaled+ln_DR_scaled|1|0, data = df_mnl)

summary(m1.t)
# -187.31
# attraction -125.38 scale-invariant
# attraction -116.06 with income factors
# -519.54 for online
```
```{r}
MNL_prob = m1.t$prob.alt
tmp = MNL_prob[,1]
MNL_prob[,1:2] = MNL_prob[,2:3]
MNL_prob[,3] = tmp
MNL_c = apply(MNL_prob,1,which.max)

sum(MNL_c==df0$rc)/length(df0$rc)*100
#60.28369 with log( income), pure attribute
# 46.80851 with log(income), log(DR)
# 69.86755 for online attraction 
```





# traditional MLE
```{r}
unregister <- function() {
  env <- foreach:::.foreachGlobals
  rm(list=ls(name=env), pos=env)
}
```


```{r}

#CRT & RTG
LL1 = function(para){
  #para[-zeta_index] = exp(para[-zeta_index])
  
  # temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =true_param$A, choice = df0$rc, rt = df0$rt)
  #temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = (1+para[npar])*true_param$A,s = true_param$s0, A =true_param$A, choice = RC, rt = RT)
  temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  #temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT,I0 = para[npar-3])
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)) temp = -1e12
  return(temp)
}
LL2 = function(para){
  #para[-zeta_index] = exp(para[-zeta_index])
  
  # temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =true_param$A, choice = df0$rc, rt = df0$rt)
  #temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = (1+para[npar])*true_param$A,s = true_param$s0, A =true_param$A, choice = RC, rt = RT)
  temp = RCPPMLBA_Lik_rtg(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  #temp = RCPPMLBA_Lik_rtg(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT,I0 = para[npar-3])


  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)) temp = -1e12
  return(temp)
}

```

#### CO

```{r}
# CO
npar = 8
LL = function(para){
 
  temp = poster(para)-log(1/200)*npar
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 =para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 8
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 7
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b =para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #6
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC,I0 = para[npar-3])
  
  if(is.na(temp)) temp = -Inf
 
  return(temp)
}

```



```{r}
unregister <- function() {
  env <- foreach:::.foreachGlobals
  rm(list=ls(name=env), pos=env)
}
```



```{r}
unregister()
library(optimParallel)
numCores = 1+2*npar#detectCores()
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))

clusterEvalQ(cl, library("numDeriv"))
clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df", "RC","RT","LL","poster"), envir = .GlobalEnv)



```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```



```{r}
tic("start")
est_mle0_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle0_list_adj_v1 = list()
mle0_list_sd_v1 = list()
i = 1
for (j in (1:200)){
  tryCatch(
    
 
  while(i<=dim(est_mle0_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)

   mle0 = optimParallel(par = init_value, fn = LL,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-100,-100,0,0,0), #8
                    upper = c(200,200,200,100,100,200,200,200), #8
                    
                    hessian = TRUE,
                    control = list(trace = 1, fnscale = -1,pgtol=1e-3),
                    parallel = list(cl=cl)) 
#} 

print(i)
        #theta.hat = fit$par                 #parameter estimate
        #sd.hat = sqrt(diag(solve(fit$hessian/(n-1))))  #se estimate
           # you could use also optimHess to evaluate the Hessian
#

if(mle0$convergence==0){
  
h_matrix = numDeriv::hessian(func = LL, x = mle0$par)
#h_matrix = mle0$hessian
#if(!is.singular.matrix(h_matrix)){
  sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))&(!is.na(sum(sd.hat)))# flag=0 is good
  if(flag){
  
    mle0_list_adj_v1[[i]] = sd.hat
    mle0_list_sd_v1[[i]] = mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle0_adj_v1[-(npar+1),i] = mle0$par
    #est_mle0[-c(zeta_index,npar+1),i] = exp(mle0$par[-zeta_index])
    #est_mle1[npar+1,i] =  mle1$maximum
    est_mle0_adj_v1[(npar+1),i] =  mle0$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()

 #45760.33 sec
```


```{r}

saveRDS(mle0_list_adj_v1,file = "CO_mle_p8_list_0501")
saveRDS(mle0_list_sd_v1,file = "CO_mle_p8_hess_0501")
saveRDS(est_mle0_adj_v1,file = "CO_mle_p8_sd_0501") 

```


```{r}
mle0_list_adj_v1 = readRDS(file = "CO_mle_p8_list_v4")
mle0_list_sd_v1=readRDS(file = "CO_mle_p8_hess_v4")
est_mle0_adj_v1=readRDS(file = "CO_mle_p8_sd_v4")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A,
               LL(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A))
)

#h_matrix = numDeriv::hessian(func = LL1, x = true_value[-(npar+1)])
#s_matrix = numDeriv::grad(func = LL1, x = true_value[-(npar+1)])
#check whether they are the same
#sd.hat = sqrt(diag(solve(-h_matrix)))

#sd.hat = 1/sqrt(diag(-h_matrix))
#sqrt(diag(solve(s_matrix%*%t(s_matrix)*N)))
mleCO_index = which.max(est_mle0_adj_v1[npar+1,])

res0 = data.frame(true = true_value,mle0 =est_mle0_adj_v1[,mleCO_index], se = c(mle0_list_adj_v1[[mleCO_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1" ,"lam2" ,"b", "Lik")
rownames(res0)=name
res0
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

# 18;2
# 3;14;16;19;26;29;30; 14 wins

```
```{r}
LL = function(para){
 
  #para[-zeta_index] = exp(para[-zeta_index])
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = (1+para[npar])*true_param$A,s = true_param$s0, A =true_param$A, choice = df0$rc)
  temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 =para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 8
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 7
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b =para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #6
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC,I0 = para[npar-3])
  
  #if(is.na(temp)) temp = -Inf
  #if(is.infinite(temp)) temp = -1e12
  return(temp)
}

```


```{r}
#res0 = est_mle0_adj_v1[,mleCO_index]
res0 = c(0.458046,36.8815735,28.2365488,0.4780895-1,0.6282405-1,0.9065484,0.3851093,0.1712379,-23.6033699)

Hess = numDeriv::hessian(func = LL, x = res0[-(npar+1)])
sqrt(diag(solve(-Hess/(N-1))))
#setDefaultCluster(cl=NULL); stopCluster(cl)
```

## new 
```{r}
npar = 7
LL = function(para){
 
  #para[-zeta_index] = exp(para[-zeta_index])
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = (1+para[npar])*true_param$A,s = true_param$s0, A =true_param$A, choice = df0$rc)
  temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 =para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 8
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 7
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b =para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #6
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC,I0 = para[npar-3])
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)) temp = -1e12
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)



#optimParallel(par =init_value, fn=LL,control = list(fnscale = -1))




```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")
est_mle0_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle0_list_adj_v1 = list()
mle0_list_sd_v1 = list()
i = 1
for (j in (1:200)){
  tryCatch(
    
 
  while(i<=dim(est_mle0_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar-1)] = runif(1,min = 0,max =1)
#init_value = c(true_param$beta,
#               true_param$zeta[-3],
#               true_param$lam1,
#               true_param$lam2,
#               true_param$b)
#mle1 = maxLik(logLik = LL1,start = init_value,method = "BFGS")
#init_value = true_value[-(npar+1)]+runif(npar,min = -1,max = 1)
#mle1 = maxLik(logLik =LL1,start =init_value,method = "BFGS")

#foreach(i = 1:(numCores-2), .verbose = FALSE, .combine = c)%dopar%{
    mle0 = optimParallel(par = init_value, fn = LL,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0,0), #7
                    upper = c(50,50,50,25,25,1,50), #7
                    #lower = c(0,0,0,-25,-25,0), #8
                    #upper = c(50,50,50,25,25,1), #8
                    hessian = TRUE,
                    control = list(trace = 1, fnscale = -1,pgtol=1e-3),
                    parallel = list(cl=cl)) 
#} 

print(i)
        #theta.hat = fit$par                 #parameter estimate
        #sd.hat = sqrt(diag(solve(fit$hessian/(n-1))))  #se estimate
           # you could use also optimHess to evaluate the Hessian
#


h_matrix = numDeriv::hessian(func = LL, x = mle0$par)
#h_matrix = mle0$hessian
#if(!is.singular.matrix(h_matrix)){
  sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))&(mle0$convergence==0) # flag=0 is good
  if(flag){
  
    mle0_list_adj_v1[[i]] = sd.hat
    mle0_list_sd_v1[[i]] = h_matrix
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle0_adj_v1[-(npar+1),i] = mle0$par
    #est_mle0[-c(zeta_index,npar+1),i] = exp(mle0$par[-zeta_index])
    #est_mle1[npar+1,i] =  mle1$maximum
    est_mle0_adj_v1[(npar+1),i] =  mle0$value
    i = i+1
}
},
  
  error=function(e){}

  )
}
toc()
# setDefaultCluster(cl=NULL); stopCluster(cl)

```


```{r}
#saveRDS(mle0,file = "CO_mle_0_list_6")
saveRDS(mle0_list_adj_v1,file = "CO_mle_p7_list_v4")
saveRDS(mle0_list_sd_v1,file = "CO_mle_p7_hess_v4")
saveRDS(est_mle0_adj_v1,file = "CO_mle_p7_sd_v4") #v2 has the same initial value as prior


```



```{r}

mle0_list_adj_v1 = readRDS(file = "CO_mle_p7_list_v4")
mle0_list_sd_v1=readRDS(file = "CO_mle_p7_hess_v4")
est_mle0_adj_v1=readRDS(file = "CO_mle_p7_sd_v4")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               true_param$b*true_param$A,
               LL(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              
               true_param$lam2,
               true_param$b*true_param$A))
)

#h_matrix = numDeriv::hessian(func = LL1, x = true_value[-(npar+1)])
#s_matrix = numDeriv::grad(func = LL1, x = true_value[-(npar+1)])
#check whether they are the same
#sd.hat = sqrt(diag(solve(-h_matrix)))

#sd.hat = 1/sqrt(diag(-h_matrix))
#sqrt(diag(solve(s_matrix%*%t(s_matrix)*N)))
mleCO_index = which.max(est_mle0_adj_v1[npar+1,])

res0 = data.frame(true = true_value,mle0 =est_mle0_adj_v1[,mleCO_index], se = c(mle0_list_adj_v1[[mleCO_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2" ,"b", "Lik")
rownames(res0)=name
res0
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

# 18;2
# 3;14;16;19;26;29;30; 14 wins
#6,15,20,24,27,30;
```

```{r}
#res0 = est_mle0_adj_v1[,mleCO_index]
res0 = est_mle0_adj_v1[,6]
Hess = numDeriv::hessian(func = LL, x = res0[-(npar+1)])
sqrt(diag(solve(-Hess/(N-1))))
#setDefaultCluster(cl=NULL); stopCluster(cl)
```


## new 2

```{r}
npar = 6
LL = function(para){
 
  #para[-zeta_index] = exp(para[-zeta_index])
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(exp(para[(nAlt+1):(npar-3)]),0),lam1 = para[npar-2],lam2 = para[npar-1],b = (1+para[npar])*true_param$A,s = true_param$s0, A =true_param$A, choice = df0$rc)
  temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 =para[npar],b = true_param$b*true_param$A,s = true_param$s0, A =true_param$A, choice = RC) #npar = 8
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #npar = 7
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b =para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC) #6
  
  #temp = RCPPMLBA_Lik_CO(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-4)],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC,I0 = para[npar-3])
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)) temp = -1e12
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)



#optimParallel(par =init_value, fn=LL,control = list(fnscale = -1))




```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")
est_mle0_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle0_list_adj_v1 = list()
mle0_list_sd_v1 = list()
i = 1
for (j in (1:200)){
  tryCatch(
    
 
  while(i<=dim(est_mle0_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar)] = runif(1,min = 0,max =1)
#init_value = c(true_param$beta,
#               true_param$zeta[-3],
#               true_param$lam1,
#               true_param$lam2,
#               true_param$b)
#mle1 = maxLik(logLik = LL1,start = init_value,method = "BFGS")
#init_value = true_value[-(npar+1)]+runif(npar,min = -1,max = 1)
#mle1 = maxLik(logLik =LL1,start =init_value,method = "BFGS")

#foreach(i = 1:(numCores-2), .verbose = FALSE, .combine = c)%dopar%{

    mle0 = optimParallel(par = init_value, fn = LL,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0), #6
                    upper = c(50,50,50,25,25,1), #6
                    #lower = c(0,0,0,-25,-25,0), #8
                    #upper = c(50,50,50,25,25,1), #8
                    hessian = TRUE,
                    control = list(trace = 1, fnscale = -1,pgtol=1e-3),
                    parallel = list(cl=cl)) 
#} 

print(i)
        #theta.hat = fit$par                 #parameter estimate
        #sd.hat = sqrt(diag(solve(fit$hessian/(n-1))))  #se estimate
           # you could use also optimHess to evaluate the Hessian
#


h_matrix = numDeriv::hessian(func = LL, x = mle0$par)
#h_matrix = mle0$hessian
#if(!is.singular.matrix(h_matrix)){
  sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))&(mle0$convergence==0) # flag=0 is good
  if(flag){
  
    mle0_list_adj_v1[[i]] = sd.hat
    mle0_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle0_adj_v1[-(npar+1),i] = mle0$par
    #est_mle0[-c(zeta_index,npar+1),i] = exp(mle0$par[-zeta_index])
    #est_mle1[npar+1,i] =  mle1$maximum
    est_mle0_adj_v1[(npar+1),i] =  mle0$value
    i = i+1
}
},
  
  error=function(e){}

  )
}
toc()
# setDefaultCluster(cl=NULL); stopCluster(cl)

```


```{r}
#saveRDS(mle0,file = "CO_mle_0_list_6")
saveRDS(mle0_list_adj_v1,file = "CO_mle_p6_list_v4")
saveRDS(mle0_list_sd_v1,file = "CO_mle_p6_hess_v4")
saveRDS(est_mle0_adj_v1,file = "CO_mle_p6_sd_v4") #v2 has the same initial value as prior


```



```{r}

npar = 6
mle0_list_adj_v1 = readRDS(file = "CO_mle_p6_list_v4")
mle0_list_sd_v1=readRDS(file = "CO_mle_p6_hess_v4")
est_mle0_adj_v1=readRDS(file = "CO_mle_p6_sd_v4")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               
               LL(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              
               true_param$lam2
               ))
)

#h_matrix = numDeriv::hessian(func = LL1, x = true_value[-(npar+1)])
#s_matrix = numDeriv::grad(func = LL1, x = true_value[-(npar+1)])
#check whether they are the same
#sd.hat = sqrt(diag(solve(-h_matrix)))

#sd.hat = 1/sqrt(diag(-h_matrix))
#sqrt(diag(solve(s_matrix%*%t(s_matrix)*N)))
mleCO_index = which.max(est_mle0_adj_v1[npar+1,])
mleCO_index = 16
res0 = data.frame(true = true_value,mle0 =est_mle0_adj_v1[,mleCO_index], se = c(mle0_list_adj_v1[[mleCO_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2" , "Lik")
rownames(res0)=name
res0
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18

```

```{r}
#res0 = est_mle0_adj_v1[,mleCO_index]
res0 = c(0.1983429,42.5884965,0.1222366,0.8928617-1,1.1292556-1,0.6108551,-28.855172)


Hess = numDeriv::hessian(func = LL, x = res0[-(npar+1)])
sqrt(diag(solve(-Hess/(N-1))))
#setDefaultCluster(cl=NULL); stopCluster(cl)
```


## CRT
### CRT npar = 8 

```{r}
score_check = function(x){
    if(is.na(tmp[i])) tmp[i] = 1e6
    if(is.infinite(tmp[i])){
    if(temp[i]>0) {temp[i] = 1e6}
    else {temp[i] = -1e6}
  }
  
}
```

```{r}
npar = 8
LL1 = function(para){
 
  temp = poster(para)-log(1/200)*npar
 
  #temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}



gn1 = function(para){
 
  temp = score_mlba_crt_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  for(i in 1:length(para)){
    if(is.na(temp[i])) temp[i] = 0
  if(is.infinite(temp[i])) {
    if(temp[i]>0) {temp[i] = 1e6}
    else {temp[i] = -1e6}
  }
  }
  
  return(temp)
  
  return(temp)
}


gn1BHHH =  function(para){
 
 temp = t(sapply(1:N, function(x){score_mlba_crt_all(attrs[(3*x-2):(3*x),],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[x], rt = RT[x])}))
  
 

  
  return(temp)
}



Hessian1_BHHH =  function(para){
 
 temp = derivative_mlba_crt_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  
  return(temp)
}
```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df", "RC","RC","RT","LL1","gn1","poster"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")


A = matrix(0,nrow = 2*npar,ncol = npar)
diag(A) = rep(1,npar)
diag(A[(npar+1):(2*npar),]) = rep(-1,npar)
B = c(rep(0,npar),rep(200,npar))
B[zeta_index] = rep(100,length(zeta_index))
B[(zeta_index+npar)] = rep(100,length(zeta_index))
est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle1_list_adj_v1 = list()
mle1_list_sd_v1 = list()
i = 1
for (j in (1:1e4)){
  tryCatch(
    
 
  while(i<=dim(est_mle1_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)



init_value[(npar-2):(npar-1)] = runif(2,min = 0,max = 2)

mle1 = maxLik::maxBHHH(start = init_value, 
                       fn = LL1,
                       grad = gn1BHHH,
                       #hess = Hessian1_BHHH,
                       #start.theta initial value of paramter
                       #constraints = list(ineqA = A,ineqB = B),
                       finalHessian = "BHHH",
                       #fixed = c(FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE),
                       control = list(reltol = -1,gradtol =0.1*sqrt(N)*npar,tol = -1) )
                        #,qac = "stephalving"

print(i)
      
check_1 = sum(A%*%mle1$estimate+B<0)
if((mle1$code%in%c(1,2))&(check_1==0)){
#h_matrix = numDeriv::hessian(func = LL1, x = mle1$par)
#w_matrix = derivative_mlba_crt_all(X = attrs,beta = mle1$estimate[1:nAttr],zeta = c(mle1$estimate[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = mle1$estimate[npar-2],lam2 = mle1$estimate[npar-1],b = mle1$estimate[npar], s = true_param$s0, A =mle1$estimate[npar]/true_param$b_A, choice = RC, rt = RT)
w_matrix = mle1$hessian
sd.hat = sqrt(diag(solve(-w_matrix/(N-1)))) 
#sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) #& (sum(eigen(w_matrix)$values>1e-3)==0)# flag=1 is good
  if(flag){
  
    mle1_list_adj_v1[[i]] = mle1 
    mle1_list_sd_v1[[i]] = sd.hat
    
    est_mle1_adj_v1[-(npar+1),i] = mle1$estimate
    
    est_mle1_adj_v1[(npar+1),i] =  mle1$maximum
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
#setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()
#878.58 sec elapsed
```


```{r}

saveRDS(mle1_list_adj_v1,file = "CRT_mle_p8_list_v1_May10")
saveRDS(mle1_list_sd_v1,file = "CRT_mle_p8_hess_v1_May10")
saveRDS(est_mle1_adj_v1,file = "CRT_mle_p8_sd_v1_May10") #v1 has the same initial value as prior


```



```{r}

npar = 8
mle0_list_adj_v1 = readRDS(file = "CRT_mle_p8_list_v4")
mle0_list_sd_v1=readRDS(file = "CRT_mle_p8_hess_v4")
est_mle0_adj_v1=readRDS(file = "CRT_mle_p8_sd_v4")
```



```{r}
LL2 = function(para){
  
  res = RCPPMLBA_Lik_rtknown(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[1], rt = RT[1])
  
  #res = RCPPpdf_MLBA_rtknown(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[1], rt = RT[1])
  
  return(res)
}

LL2(true_value[-(npar+1)])

#RT[1];RC[1]

```
```{r}
para = true_value[-(npar+1)]
#para = c(di,true_param$b_A*true_param$A)
di = sapply(1:3,function(i){RCPPdriftmean(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],choice = i)})

#RCPPdriftmean(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],choice = 1)
#1-RCPPcdf_rt(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A,choice = 1,rt = RT[1])

#1-RCPPcdf_rt_simple(d = 0.6915738,b = true_value[npar], s = true_param$s0, A =true_value[npar]/true_param$b_A, choice = RC[1], rt = RT[1])




LL3 = function(para){
  # chosen = 3 just for test
  #para = c(d1,d2,d3,b)
  tmp = (1-RCPPcdf_rt_simple(d = para[1],b = para[4], s = true_param$s0, A =para[4]/true_param$b_A, choice = 1, rt = RT[1]))*(1-RCPPcdf_rt_simple(d = para[2],b = para[4], s = true_param$s0, A =para[4]/true_param$b_A, choice = 2, rt = RT[1]))*RCPPpdf_rt_simple(d = para[3],b = para[4], s = true_param$s0, A =para[4]/true_param$b_A, choice = RC[1], rt = RT[1])
  return(tmp)
}
para_eta = c(di,true_param$b_A*true_param$A)

LL3(c(di,true_param$b_A*true_param$A))
#0.8830725*0.9997039
```

```{r}
m1 = numDeriv::genD(func = LL3,x = para_eta,method.args=list(eps=1e-4, d=0.0001, zero.tol=sqrt(.Machine$double.eps/7e-7), r=4,v=2))
m1$D[1:4]
para = true_value[-(npar+1)]

derivative_mlba_crt_eta(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A,choice = RC[1],rt = RT[1])
```



```{r}
m1 = numDeriv::genD(func = LL2,x = true_value[-(npar+1)])

m1$D[1:npar]
#m1$D[(npar+1):length(m1$D)]
para = true_value[-(npar+1)]

m2 = numDeriv::hessian(func = LL2,x = true_value[-(npar+1)])
s = score_mlba_crt_per(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[1], rt = RT[1])

sum(abs(s%*%t(s)+h))
#h = derivative_mlba_crt_per(X = attrs[1:3,],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[1], rt = RT[1])
#colSums(gn1BHHH(true_value[-(npar+1)]))
#h[lower.tri(h)]

```




```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A,
               LL1(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A
               ))
)
LL1(true_value[-(npar+1)])
h_matrix = numDeriv::hessian(func = LL1, x = true_value[-(npar+1)])
h_matrix
w_matrix = derivative_mlba_crt_all(X = attrs,beta = m2$estimate[1:nAttr],zeta = c(m2$estimate[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = m2$estimate[npar-2],lam2 = m2$estimate[npar-1],b = m2$estimate[npar], s = true_param$s0, A =m2$estimate[npar]/true_param$b_A, choice = RC, rt = RT)


  
score_res = sapply(1:100, function(x){tmp = score_mlba_crt_all(X = attrs,beta = est_mle1_adj_v1[1:nAttr,x],zeta = c(est_mle1_adj_v1[(nAttr+1):(npar-3),x]+true_param$zeta[3],true_param$zeta[3]),lam1 = est_mle1_adj_v1[npar-2,x],lam2 = est_mle1_adj_v1[npar-1,x],b = est_mle1_adj_v1[npar,x], s = true_param$s0, A =est_mle1_adj_v1[npar,x]/true_param$b_A, choice = RC, rt = RT);return(sqrt(sum(tmp^2)))})

score = score_mlba_crt_all(X = attrs,beta = true_value[1:nAttr],zeta = c(true_value[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_value[npar-2],lam2 = true_value[npar-1],b = true_value[npar], s = true_param$s0, A =true_value[npar]/true_param$b_A, choice = RC, rt = RT)
index_score = which(score_res<sqrt(N)*npar)



eigen(-Hessian1_BHHH(true_value[-(npar+1)])/(N-1))
sqrt(diag(solve(-Hessian1_BHHH(true_value[-(npar+1)])/(N-1))))
sqrt(diag(solve(-Hessian1_BHHH(mle1$estimate)/(N-1))))

colMeans(gn1BHHH(mle1$estimate))
score_mlba_crt_all

  w_matrix = derivative_mlba_crt_all(X = attrs,beta = est_mle1_adj_v1[1:nAttr,mleCRT_index],zeta = c(est_mle1_adj_v1[(nAttr+1):(npar-3),mleCRT_index]+true_param$zeta[3],true_param$zeta[3]),lam1 = est_mle1_adj_v1[npar-2,mleCRT_index],lam2 = est_mle1_adj_v1[npar-1,mleCRT_index],b = est_mle1_adj_v1[npar,mleCRT_index], s = true_param$s0, A =est_mle1_adj_v1[npar,mleCRT_index]/true_param$b_A, choice = RC, rt = RT)

colMeans(gn1BHHH(est_mle1_adj_v1[-(npar+1),mleCRT_index]))*N

```

```{r}
mleCRT_index = which.max(est_mle1_adj_v1[npar+1])

res1 = data.frame(true = true_value,mle1 =est_mle1_adj_v1[,mleCRT_index], se = c(mle1_list_sd_v1[[mleCRT_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam1","lam2" ,"b" ,"Lik")
rownames(res1)=name
res1
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18
mle1_list_adj_v1[[mleCRT_index]]

```

```{r}
#sensitivity for each parameters
real_test = est_mle1_adj_v1[-(npar+1),mleCRT_index]
#real_test 
#real_test = true_value[-(npar+1)]
b_seq = seq(from = 5,to = 13,by = 0.01)
llk = sapply(b_seq,function(x){tmp = real_test;tmp[npar] = x;return(LL1(tmp));})
#score = sapply(b_seq,function(x){tmp = real_test;tmp[npar] = x;return(score_mlba_crt_all(X = attrs,beta = tmp[1:nAttr],zeta = c(tmp[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = tmp[npar-2],lam2 = tmp[npar-1],b = tmp[npar], s = true_param$s0, A =tmp[npar]/true_param$b_A, choice = RC, rt = RT));})
plot(x = b_seq, y = llk)



#plot(x = b_seq, y = score[npar,])

#abline(h = est_mle1_adj_v1[(npar+1),mleCRT_index])
#abline(h = 0)
abline(v = true_value[npar])


```
```{r}
beta_seq = seq(from = 0,to = 15,by = 0.1)
llk = sapply(beta_seq,function(x){tmp = real_test;tmp[8] = x;return(LL1(tmp));})

plot(x = beta_seq, y = llk)
abline(h = real_test[8])
abline(v = true_value[8])

```
```{r}

lam_seq = seq(from = 1,to = 3,by = 0.01)
llk = sapply(lam_seq,function(x){tmp = real_test;tmp[7] = x;return(LL1(tmp));})

plot(x = lam_seq, y = llk)
abline(h = est_mle1_adj_v1[(npar+1),mleCRT_index])
abline(v = true_value[7])

```


```{r}
# for test the accuracy of LLK, optim, paralleloptim
m1 = maxLik::maxBFGSR(fn = LL1,start = est_mle1_adj_v1[-(npar+1),mleCRT_index],finalHessian = TRUE)
m2 = maxLik::maxBHHH(fn = LL1,grad = gn1BHHH,start = true_value[-(npar+1)],finalHessian = "BHHH",constraints = list())
sqrt(diag(solve(-m2$hessian/(N-1)))) 

```


### CRT npar = 7 

```{r}
npar = 7
LL1 = function(para){
 
  temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")


est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle1_list_adj_v1 = list()
mle1_list_sd_v1 = list()
i = 1
for (j in (1:400)){
  tryCatch(
    
 
  while(i<=dim(est_mle0_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar-1)] = runif(1,min = 0,max = 1)

mle1 = optimParallel(par = init_value, fn = LL1,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0,0), #7
                    upper = c(50,50,50,25,25,1,50), #7
                    
                    hessian = TRUE,
                    control = list( fnscale = -1),
                    parallel = list(cl=cl)) 


print(i)
      
if(mle1$convergence==0){
h_matrix = numDeriv::hessian(func = LL1, x = mle1$par)
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) # flag=0 is good
  if(flag){
  
    mle1_list_adj_v1[[i]] = sd.hat
    mle1_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    #est_mle0[-c(zeta_index,npar+1),i] = exp(mle0$par[-zeta_index])
    #est_mle1[npar+1,i] =  mle1$maximum
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()

```


```{r}

saveRDS(mle1_list_adj_v1,file = "CRT_mle_p7_list_v1")
saveRDS(mle1_list_sd_v1,file = "CRT_mle_p7_hess_v1")
saveRDS(est_mle1_adj_v1,file = "CRT_mle_p7_sd_v1") # n =60


```



```{r}

npar = 8
mle0_list_adj_v1 = readRDS(file = "CRT_mle_p7_list_v4")
mle0_list_sd_v1=readRDS(file = "CRT_mle_p7_hess_v4")
est_mle0_adj_v1=readRDS(file = "CRT_mle_p7_sd_v4")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               true_param$b*true_param$A,
               LL1(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              
               true_param$lam2,
               true_param$b*true_param$A
               ))
)


mleCRT_index = which.max(est_mle1_adj_v1[npar+1,])

res1 = data.frame(true = true_value,mle1 =est_mle1_adj_v1[,mleCRT_index], se = c(mle1_list_adj_v1[[mleCRT_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2" ,"b" ,"Lik")
rownames(res1)=name
res1
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18
```

### CRT npar = 6

```{r}
npar = 6
LL1 = function(para){
 
  temp = RCPPMLBA_Lik_rtknown(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar],b =true_param$b*true_param$A,s = true_param$s0, A =true_param$A, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")


est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle1_list_adj_v1 = list()
mle1_list_sd_v1 = list()
i = 1
for (j in (1:400)){
  tryCatch(
    
 
  while(i<=dim(est_mle0_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar)] = runif(1,min = 0,max = 1)

mle1 = optimParallel(par = init_value, fn = LL1,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0), #6
                    upper = c(50,50,50,25,25,1), #6
                    
                    hessian = TRUE,
                    control = list( fnscale = -1),
                    parallel = list(cl=cl)) 


print(i)
      
if(mle1$convergence==0){
h_matrix = numDeriv::hessian(func = LL1, x = mle1$par)
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) # flag=0 is good
  if(flag){
  
    mle1_list_adj_v1[[i]] = sd.hat
    mle1_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    #est_mle0[-c(zeta_index,npar+1),i] = exp(mle0$par[-zeta_index])
    #est_mle1[npar+1,i] =  mle1$maximum
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()

```


```{r}

saveRDS(mle1_list_adj_v1,file = "CRT_mle_p6_list_v1")
saveRDS(mle1_list_sd_v1,file = "CRT_mle_p6_hess_v1")
saveRDS(est_mle1_adj_v1,file = "CRT_mle_p6_sd_v1") 


```



```{r}

npar = 6
mle0_list_adj_v1 = readRDS(file = "CRT_mle_p6_list_v1")
mle0_list_sd_v1=readRDS(file = "CRT_mle_p6_hess_v1")
est_mle0_adj_v1=readRDS(file = "CRT_mle_p6_sd_v1")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               
               LL1(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              
               true_param$lam2
               
               ))
)


mleCRT_index = which.max(est_mle1_adj_v1[npar+1,])

res1 = data.frame(true = true_value,mle1 =est_mle1_adj_v1[,mleCRT_index], se = c(mle1_list_adj_v1[[mleCRT_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2"  ,"Lik")
rownames(res1)=name
res1
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18
```


## RTG
### RTG npar = 8
```{r}
npar = 8
LL2 = function(para){
 
   temp = RCPPMLBA_Lik_rtg(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e8)) temp = -1e8
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")
est_mle2_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle2_list_adj_v1 = list()
mle2_list_sd_v1 = list()
i = 1
for (j in (1:800)){
  tryCatch(
    
 
  while(i<=dim(est_mle2_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar-2):(npar-1)] = runif(2,min = 0,max =1)

mle2 = optimParallel(par = init_value, fn = LL2,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0,0,0), #8
                    upper = c(50,50,50,25,25,1,1,50), #8
                    
                    hessian = TRUE,
                    control = list( fnscale = -1),
                    parallel = list(cl=cl)) 


print(i)
      
if(mle2$convergence==0){
h_matrix = numDeriv::hessian(func = LL2, x = mle2$par)
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) # flag=0 is good
  if(flag){
  
    mle2_list_adj_v1[[i]] = sd.hat
    mle2_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle2_adj_v1[-(npar+1),i] = mle2$par
     
    est_mle2_adj_v1[(npar+1),i] =  mle2$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()

```


```{r}

saveRDS(mle2_list_adj_v1,file = "RTG_mle_p8_list_v1")
saveRDS(mle2_list_sd_v1,file = "RTG_mle_p8_hess_v1")
saveRDS(est_mle2_adj_v1,file = "RTG_mle_p8_sd_v1") #v1 has the same initial value as prior


```



```{r}

npar = 8
mle0_list_adj_v1 = readRDS(file = "RTG_mle_p8_list_v1")
mle0_list_sd_v1=readRDS(file = "RTG_mle_p8_hess_v1")
est_mle0_adj_v1=readRDS(file = "RTG_mle_p8_sd_v1")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               true_param$lam1,
               true_param$lam2,
               true_param$b*true_param$A,
               LL2(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
              true_param$lam1,
               true_param$lam2,
               true_param$b*true_param$A
               ))
)


mleRTG_index = which.max(est_mle2_adj_v1[npar+1,])

res1 = data.frame(true = true_value,mle1 =est_mle2_adj_v1[,mleRTG_index], se = c(mle2_list_adj_v1[[mleRTG_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam1","lam2" ,"b" ,"Lik")
rownames(res1)=name
res1
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18

```


```{r}
res2 = c(35.07194441,17.52018267,4.42058136,1.62196974-1,3.38666534-1,0.87365474,0.09789173,6.75252025)
Hess = numDeriv::hessian(func = LL2, x = res2[-(npar+1)] )
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))
sd.hat

```

### RTG npar = 7


```{r}
npar = 7
LL2 = function(para){
 
   temp = RCPPMLBA_Lik_rtg(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-2)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar-1],b = para[npar],s = true_param$s0, A =para[npar]/true_param$b, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e8)) temp = -1e8
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")
est_mle2_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle2_list_adj_v1 = list()
mle2_list_sd_v1 = list()
i = 1
for (j in (1:800)){
  tryCatch(
    
 
  while(i<=dim(est_mle2_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar-1)] = runif(1,min = 0,max =1)

mle2 = optimParallel(par = init_value, fn = LL2,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0,0), #7
                    upper = c(50,50,50,25,25,1,50), #7
                    
                    hessian = TRUE,
                    control = list( fnscale = -1),
                    parallel = list(cl=cl)) 


print(i)
      
if(mle2$convergence==0){
h_matrix = numDeriv::hessian(func = LL2, x = mle2$par)
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) # flag=0 is good
  if(flag){
  
    mle2_list_adj_v1[[i]] = sd.hat
    mle2_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle2_adj_v1[-(npar+1),i] = mle2$par
     
    est_mle2_adj_v1[(npar+1),i] =  mle2$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()

```


```{r}

saveRDS(mle2_list_adj_v1,file = "RTG_mle_p7_list_v1")
saveRDS(mle2_list_sd_v1,file = "RTG_mle_p7_hess_v1")
saveRDS(est_mle2_adj_v1,file = "RTG_mle_p7_sd_v1") #v1 has the same initial value as prior


```



```{r}

npar = 7
mle2_list_adj_v1 = readRDS(file = "RTG_mle_p7_list_v1")
mle2_list_sd_v1=readRDS(file = "RTG_mle_p7_hess_v1")
est_mle2_adj_v1=readRDS(file = "RTG_mle_p7_sd_v1")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               true_param$b*true_param$A,
               LL2(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
             
               true_param$lam2,
               true_param$b*true_param$A
               ))
)


mleRTG_index = which.max(est_mle2_adj_v1[npar+1,])

res2 = data.frame(true = true_value,mle1 =est_mle2_adj_v1[,mleRTG_index], se = c(mle2_list_adj_v1[[mleRTG_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2" ,"b" ,"Lik")
rownames(res2)=name
res2
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18

```


### RTG npar = 6

```{r}
npar = 6
LL2 = function(para){
 
   temp = RCPPMLBA_Lik_rtg(attrs,beta =para[1:nAlt], zeta = c(para[(nAlt+1):(npar-1)]+true_param$zeta[3],true_param$zeta[3]),lam1 = true_param$lam1,lam2 = para[npar],b = true_param$b*true_param$A,s = true_param$s0, A =true_param$A, choice = RC, rt =RT)
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e8)) temp = -1e8
  return(temp)
}

```

```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df0", "RC","RC","RT","LL","LL1","LL2"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

```{r}
tic("start")
est_mle2_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle2_list_adj_v1 = list()
mle2_list_sd_v1 = list()
i = 1
for (j in (1:800)){
  tryCatch(
    
 
  while(i<=dim(est_mle2_adj_v1)[2]){
  
init_value = rep(-1,npar)

init_value[zeta_index]= runif(length(zeta_index),min = -5,max = 5)

init_value[-zeta_index]= runif((npar-length(zeta_index)),min = 0,max =20)
init_value[(npar)] = runif(1,min = 0,max =1)

mle2 = optimParallel(par = init_value, fn = LL2,    #start.theta initial value of paramter
                    method = "L-BFGS-B",     #hessian True to calculate Hessian matrix
                    lower = c(0,0,0,-25,-25,0), #6
                    upper = c(50,50,50,25,25,1), #6
                    
                    hessian = TRUE,
                    control = list( fnscale = -1),
                    parallel = list(cl=cl)) 


print(i)
      
if(mle2$convergence==0){
h_matrix = numDeriv::hessian(func = LL2, x = mle2$par)
sd.hat = sqrt(diag(solve(-h_matrix/(N-1))))  # NA is caused since diag of Fisher is negative.
  #is.na(sum(sd.hat))|
  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) # flag=0 is good
  if(flag){
  
    mle2_list_adj_v1[[i]] = sd.hat
    mle2_list_sd_v1[[i]] = h_matrix#mle0$hessian
    #est_mle1[-(npar+1),i] = mle1$estimate
    est_mle2_adj_v1[-(npar+1),i] = mle2$par
     
    est_mle2_adj_v1[(npar+1),i] =  mle2$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()
setDefaultCluster(cl=NULL); stopCluster(cl);stopImplicitCluster()
```



```{r}

saveRDS(mle2_list_adj_v1,file = "RTG_mle_p6_list_v1")
saveRDS(mle2_list_sd_v1,file = "RTG_mle_p6_hess_v1")
saveRDS(est_mle2_adj_v1,file = "RTG_mle_p6_sd_v1") #v1 has the same initial value as prior


```



```{r}

npar = 6
mle2_list_adj_v1 = readRDS(file = "RTG_mle_p6_list_v1")
mle2_list_sd_v1=readRDS(file = "RTG_mle_p6_hess_v1")
est_mle2_adj_v1=readRDS(file = "RTG_mle_p6_sd_v1")
```









```{r}
library(Countr)
true_value = c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
               
               true_param$lam2,
               
               LL2(c(true_param$beta,
               true_param$zeta[-3]-true_param$zeta[3],
             
               true_param$lam2))
)


mleRTG_index = which.max(est_mle2_adj_v1[npar+1,])

res2 = data.frame(true = true_value,mle1 =est_mle2_adj_v1[,mleRTG_index], se = c(mle2_list_adj_v1[[mleRTG_index]],"-"))
#name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2","lam1","lam2" ,"b", "Lik")

name = c("betaRC","betaOC","betaDR", "zeta1", "zeta2" ,"lam2"  ,"Lik")
rownames(res2)=name
res2
#2;logllk = -0.2550404
#res0 = est_mle0_adj_v1[,2]

#1;12;18:18

```




# 2.1 Initialization
```{r}
K = npar*3
M = 5e4
burn_in = 3e4
gam = 2.38/sqrt(2*npar)
```


```{r}
# Set chain number K and iteration number M
tic("initial time")



# initialize chains. the last column is for likelihood
chain_int = matrix(nrow = K, ncol = npar+1)
chain_list = list()
theta_0 = chain_int

  theta_0[,zeta_index] = runif(K*length(zeta_index), min = -100, max = 100)
  theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 200)
  #theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 5)
  theta_0[,(npar-2):(npar-1)] = runif(K*2, min = 0 , max = 5)
  #theta_0[,(npar-1)] = runif(K, min = 0 , max = 5)
  #theta_0[,npar] = runif(K, min = 0 , max = 1)
  #theta_0[,-c(npar+1)] = runif(K*(npar), min = 0 , max = 100)
  
  #theta_0[,1] = rnorm(K, mean = 1, sd = .5)
  #theta_0[,2] = rnorm(K, mean = 2, sd = .5)
  #theta_0[,3] = rnorm(K, mean = log(0.3), sd = .5)
  #theta_0[,4] = rnorm(K, mean = log(0.5), sd = .5)
  #theta_0[,5] = rnorm(K,mean = log(3), sd = .5)
  #theta_0[,6] = rnorm(K,mean = log(0.1), sd = .5)
  #theta_0[,7] = rnorm(K, mean = log(0.5), sd = .5)
  #theta_0[,8] = rnorm(K, mean = log(10), sd = .5)
  #theta_0[,8] = rnorm(K,mean = log(10), sd = .5)
 


theta_0[,(npar+1)] = sapply(1:K, function(x){return (poster(theta_0[x,-(npar+1)]))})

# check whether All Likelihood is smaller than Inf
index = which(is.infinite(theta_0[,(npar+1)]))

while (length(index)) {
  
  theta_0[index,zeta_index] = runif(length(index)*length(zeta_index), min =-100, max = 100)
  #theta_0[index,-c(zeta_index,npar+1)] = runif(length(index)*(npar-length(zeta_index)), min = -3, max = 7)
  theta_0[index,-c(zeta_index,npar+1)] = runif(length(index)*(npar-length(zeta_index)), min = 0, max = 200)
  #theta_0[index,(npar)] = runif(length(index), min = 0 , max = 1)
  #theta_0[index,(npar-1)] = runif(length(index), min = 0 , max = 5)
  theta_0[index,(npar-2):(npar-1)] = runif(length(index)*2, min = 0 , max = 5)
  
  
  #theta_0[index,-c(npar+1)] = runif(length(index)*(npar), min = 0, max = 100)
 
  #theta_0[index,1] = rnorm(length(index), mean = 1, sd = .5)
  #theta_0[index,2] = rnorm(length(index), mean = 2, sd = .5)
  #theta_0[index,3] = rnorm(length(index), mean = log(0.3), sd = .5)
  #theta_0[index,4] = rnorm(length(index), mean = log(0.5), sd = .5)
  
  #theta_0[index,5] = rnorm(length(index), mean = log(3), sd = .5)
  #theta_0[index,6] = rnorm(length(index), mean = log(0.1), sd = .5)
  #theta_0[index,7] = rnorm(length(index), mean = log(0.5), sd = .5)
  #theta_0[index,8] = rnorm(length(index), mean = log(10), sd = .5)

  theta_0[index,(npar+1)] = sapply(index, function(x){return (poster(theta_0[x,-(npar+1)]))})
  index = which(is.infinite(theta_0[,(npar+1)]))

  print(paste("Still has", length(index), "to find."))
}
chain_list[[1]] = theta_0
toc()
gam = 2.38/sqrt(2*npar)

chain_list[[1]]
# 166.5 sec online_att
# 15.33 sec lab_att
```




### 2.2 Crossover
```{r}

Update_para = function(para){
  # para = list(ChainIndex,last_chainlist,gamma)
  # last_chainlist is a matrix each row means the last step value of each chain and the last column is the liklihood of the corresponding parameters
 
  theta_prev = para$last_chain[para$ChainIndex,-(npar+1)]
  # randomly draw two chain from all chains except current chain
  de_ChainIndex = sample(probset[-para$ChainIndex], size = 2,replace = FALSE)
  theta_m = para$last_chain[de_ChainIndex[1],-(npar+1)] 
  theta_n = para$last_chain[de_ChainIndex[2],-(npar+1)] 
  # generate new theta, the here are 6 parameters to estimate in total
  add = runif(npar, min = -0.01, max = 0.01)#npar

  theta_new = theta_prev + para$gamma* (theta_m - theta_n) + add
  
  new_post = poster(theta_new)
  prev_post = para$last_chain[para$ChainIndex,(npar+1)]

  # accept rate
  alpha = runif(1)
  
  ratio = exp(new_post-prev_post)
  #if(is.na(ratio)) ratio = 0
  if( alpha> ratio) temp = c(theta_prev,prev_post) else temp = c(theta_new,new_post)
    
  
  return(temp)
  }
  

```



```{r}
De_MCMC_unit = function(prev, X, gam1){
  
  para = list(ChainIndex = X, last_chain = prev, gamma = gam1)#runif(1,.5,1)
  Update_para(para)
}

```

```{r,results='hide'}

#numCores <- detectCores()
numCores = K+2
probset = 1:K
# use enough cores to do parallel computation ,but not overload CPU
#cl <- makeCluster(numCores[1]-2) 
cl = makeCluster(numCores-2) 
registerDoParallel(cl)
# settings for parallel computing
clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))


clusterExport(cl, c("file_route","true_param", "De_MCMC_unit", "poster", "Update_para", "K","gam", "cl", "N","probset",  "npar", "attrs", "nAlt","zeta_index" ,"nAttr", "RT","RC"), envir = .GlobalEnv) #,"df", "RC","RT"
#
```



```{r, results='hide'}
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores-2), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```



```{r}

tic("simulation cost time with parallel computation:")
for (j in 1:M) {
  chain_list[[j+1]] = chain_int
  chain_list[[j+1]] = t(parSapply(X = 1:K, FUN = De_MCMC_unit, prev = chain_list[[j]], gam1 = gam, cl = cl))
  
  # immigration step (only works at certain steps at early stage)
  if ((j<round(burn_in*0.9))&(runif(1)<0.2)){


    temp_ssize = ceiling(runif(1,min = 1, max = K))
    temp_sample =sample(1:K,temp_ssize,replace = FALSE)
    
    theta_res = chain_list[[j+1]][temp_sample[1],]
    for (g in 1:temp_ssize){
     temp_theta = chain_list[[j+1]][temp_sample[g],-(npar+1)]
     add = runif(npar, min = -0.01, max = 0.01)#npar
     #add[npar] = runif(1,min = -0.001,max = 0.001)
     
     #add[5] = runif(1, min = -0.001, max = 0.1)
    
      if(g==1) new_theta = chain_list[[j+1]][temp_sample[temp_ssize],-(npar+1)] +add
     # previous item 
      else  new_theta = theta_res[-(npar+1)] + add
     
      new_post = poster(new_theta)
      prev_post = theta_res[(npar+1)]
      theta_res = chain_list[[j+1]][temp_sample[g],]
      
      alpha = runif(1)
      ratio = exp(new_post-prev_post)
      #if(is.na(ratio)) ratio = 0
      if(alpha<ratio)  chain_list[[j+1]][temp_sample[g],] = c(new_theta,new_post)
      #theta_res = chain_list[[j+1]][temp_sample[g],]
  
    }
    
  }
  if(j%%100==0) {cat("Simulation progress: " ,as.character(round(j/M*100),3) ,"% has finished","\n")}  } 
toc() 
stopImplicitCluster()
# 56.92 sec CRT
# 18151.15 sec CO
```

```{r}

saveRDS(chain_list, file = "chain_list_CRTH_sim(9)_v2") # M =3e4, burn_in = 1.5e4, mig_rate = 0.1, all

#saveRDS(chain_list, file = "chain_list_CO_sim(8)") # M =2e4, burn_in = 1e4, mig_rate = 0.1, all


```

# results import
```{r}
chain_list = readRDS("chain_list_RTG_sim(8)_May20")

#chain_list = readRDS("chain_list_RTG_sim(8)_May15")
#chain_list = readRDS("chain_list_RTG_sim(8)_May15")
```

```{r}
npar = dim(chain_list[[1]])[2]-1
K = dim(chain_list[[1]])[1]
M = length(chain_list)-1
burn_in = round(M/2,0)
npar;K;M;burn_in
```
```{r}
# fast route
library(bayestestR)
set.seed(2024)
chain_all = chain_list

thin = sort(sample((burn_in*1.6):M,2e3,replace = F))

est1 = sapply(chain_all[thin], colMeans)
est2 = sapply(chain_all, function(x){apply(x,2,sd)})
est3 = sapply(chain_all[thin], function(x){apply(x, 2, median)})
est3[zeta_index,] = est3[zeta_index,] 
est_median = est3


Supper_chain = array(dim = c(K,length(thin),npar+1))
for(i in 1:K){
Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
}
post = matrix(nrow = npar+1,ncol = K*length(thin))
post_sd = rep(NULL,npar+1)
for (j in 1:(npar+1)){
  post[j,] = matrix(Supper_chain[,,j],nrow = 1)
  post_sd[j] = sd(post[j,])

}
Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]
post[zeta_index,] = post[zeta_index,]



true_value = c(true_param$beta,
               #true_param$beta[-1]/true_param$beta[1],#[-1],
               true_param$zeta[-3],
               true_param$I0,
               true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A)
```



```{r}
library(bayestestR)
set.seed(2024)
chain_all = chain_list

thin = sort(sample((burn_in*1.5):M,2e3,replace = F))

est1 = sapply(chain_all[thin], colMeans)
est2 = sapply(chain_all, function(x){apply(x,2,sd)})
est3 = sapply(chain_all[thin], function(x){apply(x, 2, median)})
est3[zeta_index,] = est3[zeta_index,] 
est_median = est3


Supper_chain = array(dim = c(K,length(thin),npar+1))
for(i in 1:K){
Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
}
post = matrix(nrow = npar+1,ncol = K*length(thin))
post_sd = rep(NULL,npar+1)
for (j in 1:(npar+1)){
  post[j,] = matrix(Supper_chain[,,j],nrow = 1)
  post_sd[j] = sd(post[j,])

}
#Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]


post_mean = apply(post,1, mean)
post_mean[npar+1] = poster(post_mean[-(npar+1)])
 
post_median = apply(post , 1, median)
post_median[npar+1] = poster(post_median[-(npar+1)])


true_value = c(true_param$beta,
               #true_param$beta[-1]/true_param$beta[1],#[-1],
               true_param$zeta[-3],#[-length(true_param$zeta)],#-true_param$zeta[3],
               true_param$I0,
               true_param$lam1,
               true_param$lam2,
               true_param$b_A*true_param$A,
               poster(c(true_param$beta,
                       
                        true_param$zeta[-3]-true_param$zeta[3],
                        true_param$I0,
                        true_param$lam1,
                        true_param$lam2,
                        true_param$b_A*true_param$A
                        
                       ))) 


#name = c("betaA","betaB","betaC", "zeta1", "zeta2","I0","lam1", "lam2","b" ,"Lik")
name = c("betaA","betaB","betaC", "zeta1","zeta2","I0", "lam1", "lam2","b" ,"Lik")
#name = c("betaA","betaB", "zeta1", "zeta2","lam1", "lam2","b" ,"Lik")

HDI_para = apply(post, 1,function(x){temp = hdi(x, ci = 0.95, verbose = FALSE); return (c(temp$CI_low, temp$CI_high))},simplify = TRUE)

# DE_MLE
est_MLE = rbind.fill.matrix(chain_all)
MLE_index = which.max(est_MLE[,(npar+1)])
MLE_value = est_MLE[MLE_index,]


result4 = data.frame( true =true_value,est_mean = round(post_mean,3),est_median = round(post_median,3), sd = round(post_sd,3),hdi_95 = c(sapply(1:npar, function(x){paste("( ", round(t(HDI_para)[x,1],3),", ",round(t(HDI_para)[x,2],3),")")}),"-"),MLE = round(est_MLE[MLE_index,],3),bias = sapply(round((est_MLE[MLE_index,]-true_value)/true_value*100,2), function(x){paste(x,"%")}))
post_app = rep(NULL,npar+1)
rownames(result4) = name

result4
```

# MLE
## preperation
```{r}
unregister <- function() {
  env <- foreach:::.foreachGlobals
  rm(list=ls(name=env), pos=env)
}
```

```{r}
# objective function setup
LL1 = function(para){
 
  temp = poster(para)#-log(1/200)*(npar-2)-log(1/5)*2
  
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}



gn1 = function(para){
 
  #temp = score_mlba_crt_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  #temp = score_mlba_co_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC)
  temp = score_mlba_rtg_all(attrs,beta = para[1:(nAttr)],zeta = c(para[zeta_index]+true_param$zeta[3],true_param$zeta[2],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  #temp = numDeriv::grad(func = LL1,x = para)
  temp = temp[-5]
  for(i in 1:length(para)){
    if(is.na(temp[i])) temp[i] = 0
  if(is.infinite(temp[i])) {
    if(temp[i]>0) {temp[i] = 1e6}
    else {temp[i] = -1e6}
  }
  }
  
  return(temp)
  
  return(temp)
}


gn1BHHH =  function(para){
 
 #temp = t(sapply(1:N, function(x){score_mlba_crt_all(attrs[(3*x-2):(3*x),],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[x], rt = RT[x])}))
  #temp = t(sapply(1:N, function(x){score_mlba_co_all(attrs[(3*x-2):(3*x),],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[x])}))
  
 temp = t(sapply(1:N, function(x){score_mlba_rtg_all(attrs[(3*x-2):(3*x),],beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC[x], rt = RT[x])}))

  
  return(temp)
}



Hessian1_BHHH =  function(para){
 
 #temp = derivative_mlba_crt_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
 
 
 #temp = derivative_mlba_co_all(attrs,beta = para[1:nAttr],zeta = c(para[(nAttr+1):(npar-3)]+true_param$zeta[3],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC)
 
 temp = derivative_mlba_rtg_all(attrs,beta = para[1:(nAttr)],zeta = c(para[zeta_index]+true_param$zeta[3],true_param$zeta[2],true_param$zeta[3]),lam1 = para[npar-2],lam2 = para[npar-1],b = para[npar], s = true_param$s0, A =para[npar]/true_param$b_A, choice = RC, rt = RT)
  
  return(temp)
}
```


```{r}
unregister()
library(optimParallel)
numCores = min(1+2*npar,detectCores())
cl <- makeCluster(numCores) # set the number of processor cores
#setDefaultCluster(cl=cl) # set 'cl' as default cluster


clusterEvalQ(cl, library("doParallel"))
clusterEvalQ(cl, library("parallel"))
clusterEvalQ(cl, library("foreach"))
clusterEvalQ(cl, library("Rcpp"))
clusterEvalQ(cl, library("RcppArmadillo"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("RcppNumerical"))
clusterEvalQ(cl, library("numDeriv"))

clusterExport(cl, c("file_route","true_param","cl", "N","npar", "attrs", "nAlt","zeta_index" ,"nAttr", "df", "RC","RT","LL1","gn1","poster"), envir = .GlobalEnv)

```

```{r}
registerDoParallel(cl =cl,cores = numCores)
boolFalse=F
while(boolFalse==F)
{
  tryCatch({
    foreach(i = 1:(numCores), .verbose = FALSE, .combine = c)%dopar%{
    sourceCpp(file_route)
} 
    boolFalse=T
  },error=function(e){
  },finally={})
}

```

## result
```{r}
est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = 30)
mle1_list_adj_v1 = list()
mle1_list_sd_v1 = list()
i = 1
L_vec = diag(1,nrow = npar)
for (j in (1:1e4)){
  tryCatch(
    
 
  while(i<=dim(est_mle1_adj_v1)[2]){
  






par_value = MLE_value[-(npar+1)]+runif(npar,min = -1,max = 1)

par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(max(x,0))})


par_value[zeta_index] = par_value[zeta_index]-true_param$zeta[3]

mle1 = optimParallel(par = par_value,
      fn =LL1, gr = gn1, 
      method = "L-BFGS-B",
      lower = c(0,0,0,-100,-100,0,0,0), #8
      upper = c(200,200,200,100,100,10,10,200), #8
      control = list(fnscale = -1,maxit = 1e4,
                     ndeps = c(1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3),
                     trace = 0,
                     pgtol = 1e-3*N),
      parallel = list(cl=cl))


print(i)
      

if(mle1$code==0){

w_matrix = L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec)

sd.hat = sqrt(diag(solve(-w_matrix)))

  flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat))) 
  if(flag){
  
    mle1_list_adj_v1[[i]] = mle1 
    mle1_list_sd_v1[[i]] = sd.hat
    
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    i = i+1
}}
},
  
  error=function(e){}

  )
}
toc()



```


```{r}

par_value  = MLE_value[-(npar+1)]#post_median[-(npar+1)]
  ##+runif(npar,min = -0.5,max = 0.5)
par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(max(x,0))})
par_value[zeta_index]  = par_value[zeta_index]-true_param$zeta[3]
crt_mle = optim(par = par_value,
      fn =LL1, #gr = gn1, 
      method = "L-BFGS-B",
      lower = c(0,0,0,-100,0,0,0),
      upper = c(200,200,200,100,5,5,200),
      control = list(fnscale = -1,maxit = 1e4,
                     ndeps = c(1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3),
                     trace = 0,
                     pgtol = 1e-2),
      hessian = TRUE
      )


sqrt(diag(solve(-crt_mle$hessian)))
crt_mle$convergence 
crt_mle_value = crt_mle$par
crt_mle_value[zeta_index] = crt_mle_value[zeta_index]+true_param$zeta[3]
L_vec = matrix(0,nrow = npar,ncol = 8)
diag(L_vec[,-5]) = 1
#L_vec =diag(1,nrow = npar,ncol = npar)
#L_vec

#crt_mle_value = c(2.192,6.993,10.053,-0.006,-0.974,3.312,0.149,5.106)
#sd = c(2.805,6.463,8.849,0.749,1.409,4.201,0.107,9.352)

lo = crt_mle_value-1.96*sqrt(diag(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec))))
up = crt_mle_value+1.96*sqrt(diag(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec))))
res = data.frame(mle = round(c(crt_mle_value,crt_mle$value),3),se = c(round(sqrt(diag(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec)))),3),"-"),grad = c(gn1(par_value)/N,"-"),eigen_value = c(eigen(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec)))$value,max(eigen(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec)))$value)/min(eigen(solve(-L_vec%*%Hessian1_BHHH(par_value)%*%t(L_vec)))$value)))
res
# 
#res1 = data.frame(mle = NULL, lo = NULL, up = NULL,type = NULL)
#tmp = data.frame(mle = crt_mle_value, lo = lo, up = up,type = rep("RTG",npar))
#res1 = rbind(res1,tmp)
#write.csv(res1,"MLE_all3type_sim.csv")
```


# violon plot


```{r}
library(readr)
name1 = c(expression(paste(beta[A])),
          expression(paste(beta[B])),
          expression(paste(beta[C])),
          expression(paste(zeta[1])),expression(paste(zeta[2])),
          #expression(paste(zeta[EVB])),
          #expression(paste(I0)),
          expression(paste(lambda[1])),
          expression(paste(lambda[2])),
          "b",
          "LLK")
#post1 = read_csv("post1.csv")
#post2 = read_csv("post2.csv")
#post3 = read_csv("post3.csv")

#post1 = t(post)#CRT
#post2 = t(post) # RTG

#post3 = t(post) #CO_O

#post4 = t(post) #CO_R
#post1 = post3
#post2 = post3

#post1 = data.frame(post1, type = rep("CRT",dim(post1)[1]))
#post2 = data.frame(post2, type = rep("RTG",dim(post2)[1]))


#post5 = data.frame(post3, type = rep("CO_O",dim(post3)[1]))
#post6 = data.frame(post4, type = rep("CO_R",dim(post4)[1]))
#post7 = data.frame(post1, type = rep("CRT",dim(post1)[1]))
#post8 = data.frame(post2, type = rep("RTG",dim(post2)[1]))


#df = rbind(post1,post2,post3,post4)
#write.csv(df,"df_violin_sim_4type.csv")
#df = read.csv("df_violin_sim_CO2.csv")
df = read.csv("df_violin_sim_type3.csv")
df= rbind(post7,post8,post6)
df = df[,-1]
df1 = df[which(df$type!="CO_O"),]
colnames(df) =c(name1,"type")
colnames(df1) =c(name1,"type")
name_df = c(name1[-(npar+1)],"type")
  
true_value_sd = matrix(c(0,8,0,22,0,51.5,-3.8,4.4,-6.5,6.5,0,5.1,0,2.5,0,69),nrow = 2)




head(df1)
#write.csv(df,"df_violin_sim_type3.csv")
```

```{r}
#write.csv(df,"violin_adj_v1(8).csv")
```


```{r}
index = c(seq(from = 1,to = npar*3,by = npar),seq(from = 2,to = npar*3,by = npar),seq(from = 3,to = npar*3,by = npar),seq(from = 6,to = npar*3,by = npar),seq(from = 7,to = npar*3,by = npar),seq(from = 8,to = npar*3,by = npar))

res1[index,2] = sapply(index,function(x){return(max(res1[x,2],0))})

#write.csv(res,"sim_type3_final_MLE.csv")
```


```{r}

library(ggpubr)
library(ggplot2)
#ggarrange
MLE_df1 = MLE_df[which(MLE_df$type!="CO_O"),]
MLE_df1$type[which(MLE_df1$type=="CO_R")] = "CO"

df$type[which(df$type=="CO_R")] = "CO"
test = list()

i = 1
j = 1
while(i<=8){
  #if(i>=6) {j = i+1}
  ##else{j = i}
  j = i
  res_tmp =data.frame(MLE_df1[seq(from = i,to = npar*3,by =npar),])
  test[[i]]= ggplot()+geom_violin (data = df, aes_(x = df[,10], y = df[,j]),fill = "#C4B5E0", alpha = 1,trim = TRUE,color = "#7A84F5")+
    geom_pointrange(data = res_tmp, aes(x = type, y = est,ymin = lo,ymax =up), fill = "#669157",linewidth =0.7,shape = 24,alpha = 1,size = 0.3,color = "#669157")+
    geom_errorbar(data = res_tmp, aes(x = type, y = est,ymin = lo,ymax =up), color = "#669157",linewidth =0.9,width = 0.15)+
    #geom_hline(aes_(yintercept = true_value[j]),color = "#42376a", linetype = 2,linewidth =1)+
    #geom_boxplot(data = df, aes_(x = df[,10], y = df[,j]),outlier.shape = NA,width = 0.04, color = "blue",linewidth = 0.4)+
  geom_point(aes_(x =c("CO","CRT","RTG"), y = rep(true_value[j],3)), fill = "#6d1950", shape = 21,size = 2,alpha = 0.7,color ="#6d1950")+
  theme_classic()+
  labs(x = "",y = name_df[j])+ylim(true_value_sd[1,j],true_value_sd[2,j])
  i = i+1
}
#test[[8]] = test[[8]]+coord_cartesian(ylim = c(0, 20))

ggarrange(plotlist = test, ncol = 2, nrow = 4)
```




```{r}
ggplot(df, aes(cut, x, fill = cut)) +
geom_violinhalf(position = position_nudge(x = .2, y = 0)) +
geom_jitter(alpha = 0.01, width = 0.15) +
theme(legend.position = "none")
```

```{r}
df_mle = data.frame(est = crt_mle_value, Lo =crt_mle_value-1.96*as.numeric(res[-(npar+1),2]), Up = crt_mle_value+1.96*as.numeric(res[-(npar+1),2]), type = rep("CO",npar))
df_mle
```



```{r}
library(readxl)
MLE_df = read_excel("D:/onedrive/OneDrive - National University of Singapore/MLE_df.xlsx")

res1 = MLE_df[which(MLE_df$type%in%c("CO_O","CO_R")),]
res1
#true_value_sd = matrix(c(0,10,0,20,0,42,-2,2,-4,3.5,0,5.1,0,1,0,25),nrow = 2)
```


```{r}
library(ggplot2)
library(see)
library(ggpubr)
test1 = list()

i = 1
j = 1
while(i<=8){

j = i
res_tmp = data.frame(res1[seq(from = i,to = npar*2,by =npar),])
#res1_tmp = data.frame(res_tmp[which(res_tmp$type=="CO_O"),])
#res2_tmp = data.frame(res_tmp[which(res_tmp$type=="CO_R"),])
df1_tmp = df[which(df$type=="CO_O"),]
df2_tmp = df[which(df$type=="CO_R"),]

  test1[[i]]= 
ggplot()+
    geom_violinhalf(data = df2_tmp, aes_(x = "",y = df2_tmp[,j]), alpha = 0.5,trim = F,fill = "#6d1950",color = "white",flip = T)+
    geom_violinhalf(data = df1_tmp, aes_(x = "",y = df1_tmp[,j]), alpha = 0.5,trim = F,fill = "#d48849",color = "white")+
    geom_pointrange(data = res_tmp, aes(x = "", y = est,ymin = lo,ymax =up,group = type,fill = type),linewidth =0.05,shape = 24,alpha = 1,size = 0.3,position = position_dodge(width=-0.2),linetype = 0)+
    geom_errorbar(data = res_tmp, aes(x ="", y = est,ymin = lo,ymax =up,group = type,color = type),linewidth =0.5,width = 0.2,position = position_dodge(width=-0.2))+
    #geom_boxplot(data = df, aes_(x = df[,10], y = df[,j]),outlier.shape = NA,width = 0.04, color = "blue",linewidth = 0.4)+
  #geom_point(aes_(x = "", y = true_value[j]), fill = "#6d1950", shape = 21,size = 2,alpha = 0.5)+
  geom_hline(aes_(yintercept = true_value[j]),color = "#42376a", linetype = 2,linewidth =1)+
  theme_classic()+
  labs(x = "",y = name_df[j])+ylim(true_value_sd[1,j],true_value_sd[2,j])+
  scale_color_discrete(type = c("#d48849","#6d1950"),labels = c( expression(CO^O),expression(CO^R)))+
  scale_fill_discrete(type = c("#d48849","#6d1950"),labels = c(expression(CO^O),expression(CO^R)))
  i = i+1
}
```


```{r}
ggarrange(plotlist = test1,nrow = 4,ncol = 2,common.legend = T)
```


```{r}

test2 = list()

i = 1
j = 1
while(i<=8){

j = i
test2[[i]]=ggplot()+
    geom_density(data = df,aes_(x = df[,i],fill = df[,10]),alpha = 0.5,color = "white")+
  geom_vline(aes_(xintercept = true_value[j]),color = "#42376a", linetype = 2,linewidth =1)+
  theme_classic()+
  labs(x = "",y = name_df[j])+xlim(true_value_sd[1,j],true_value_sd[2,j])+
  scale_fill_discrete(type = c("#d48849","#6d1950"),name = "type",labels = c(expression(CO^O),expression(CO^R)))
  i = i+1
}#
```

```{r}
ggarrange(plotlist = test2,nrow = 2,ncol = 4,common.legend = T)
```



##########################################################################################


# 3. estimation Result

## basic diagnosis plot
```{r}

name1 = c(expression(paste(beta[A])),
          expression(paste(beta[B])),
          expression(paste(beta[C])),
          expression(paste(zeta[1])),expression(paste(zeta[2])),
          #expression(paste(zeta[EVB])),
          #expression(paste(I0)),
          expression(paste(lambda[1])),
          expression(paste(lambda[2])),
          "b",
          "LLK")
par(mfrow = c(2,4))
true_value_sb = true_value
low = c(0,0,0,-2,-3,0,0,5)
upper = c(3,10,15,2,5,5,3,20)
#low= c(0,0,-1,-5,0.2,0,5)
#upper = c(3,5,1,5,5,3,20)
step = c(0.1,0.1,0.1,0.1,0.1,0.05,0.05,0.5)
#step = c(0.1,0.1,0.1,0.1,0.1,0.5,0.5)
for(i in 1:npar ){
   
  lam1_seq = seq(from = low[i], to =upper[i], by = step[i])
#MLE_value
LLK_lam = sapply(lam1_seq, function(m) {tmp = crt_mle$par[-(npar+1)]; tmp[i] =m; return(LL1(tmp))})
if(i %in% zeta_index){lam1_seq = lam1_seq+true_param$zeta[3]}
  
plot(lam1_seq,LLK_lam, type = "l",xlab = name1[i],ylab = "log likelihood value")
abline(h = crt_mle$value,col = "blue", lty=2)
abline(v = true_value_sb[i],col = "red")
abline(v = crt_mle_value[i],col = "blue")
  
}

```


```{r}
# trace plot to check whether the rest of chains are stable, sample size = 1e3

name1 = c(expression(paste(beta[A])),
          expression(paste(beta[B])),
          expression(paste(beta[C])),
          expression(paste(zeta[1])),expression(paste(zeta[2])),
          #expression(paste(zeta[EVB])),
          expression(paste(I0)),
          expression(paste(lambda[1])),
          expression(paste(lambda[2])),
          "b",
          "LLK")
par(mfrow = c(3,3))
#low = c(0,0,0,-2,-2.5,0,0,0,0,-200)
#high = c(10,20,40,1,0.5,5,5.5,0.8,25,-195)
for (i in 1:(npar)){
  
   plot(as.vector(Supper_chain[1,,i]),type = "n", main = "",xlab = "iteration after burn-in period", ylab = name1[i])#,ylim = c(low[i],high[i])
  #-1.2*(i%in%c(2,5,6))
  for(k in 1:K){
    lines(as.vector(Supper_chain[k,,i]),type = "l",col = k)

  }
  #lines(x = c(1:length(thin)),y = est_median[i,], col = "red",lwd = 1.8)
  abline(h = true_value[i],col = "red",lwd = 2)
}

```


```{r}

low = c(0,1,0,-1,-3,0,0,0,8,-200)
high = c(5,12,40,0,0,4,5.5,0.7,15,-195)
par(mfrow = c(3,3))
for (i in 1:(npar+1)){
  plot(density(as.vector(post[i,]),kernel = "gaussian"),main = "",xlab = "", ylab = name1[i])#,xlim=c(low[i],high[i])
  abline(v = true_value[i], col = "red",lwd = 2)
  #abline(v = MLE_value[i], col = "red",lwd = 2)
}
```



```{r}
par(mfrow = c(3,3))

for (i in 1:(npar)){
   plot(1:length(est2[i,]),est2[i,],type = "l", main = "sd of chains",xlab = "interation", ylab = name1[i])
  #abline(h = true_value[i], col = "red",lwd = 2)
}


```
## acc& brier
```{r}
library(tictoc)

acc= function(est_para1){
  prob = NULL
  for (j in 1:nAlt){

    ############################# CRT/RTG
   #temp = MLBA_rtknown_all(attrs,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)],true_param$zeta[3]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N), rt = RT,I0 =est_para1[npar-3] ) 
   
   temp = MLBA_rtg_all(attrs,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N), rt = RT) 
          
  #temp = RCPPcdf_MLBA_CO_all(attrs,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N))

    prob = cbind(prob,temp)

  }
  discard = which(prob[,1]==prob[,2])
  #discard = integer(0)
  if(length(discard)==0) {chosen_est = apply(prob, 1, which.max)
  #acc = sum(chosen_est==df0$rc)/N*100}
  acc = sum(chosen_est==RC)/N*100}
  else{
    chosen_est = rep(-1,dim(prob)[1])
    chosen_est[-discard] = apply(prob[-discard,], 1, which.max)
  
    #acc = sum(chosen_est[-discard]==df0$rc[-discard])/(N-length(discard))*100
    acc = sum(chosen_est[-discard]==RC[-discard])/(N-length(discard))*100
  }
  
  return(c(acc,length(discard)))
  
}
acc(true_value)
acc(post_mean[-(npar+1)])
acc(post_median[-(npar+1)])
acc(MLE_value[-(npar+1)])
acc(crt_mle_value)


```

```{r}
Brier_CRT = function(para){
  RCPP_brier_CRT(attrs,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC, rt = RT)
}
Brier_RTG = function(para){
  RCPP_brier_RTG(attrs,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC, rt = RT)
}
Brier_CO = function(para){
  RCPP_brier_CO(attrs,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC)
}

```



```{r}
Brier_CRT(true_value)
Brier_CRT(post_mean[-(npar+1)])
Brier_CRT(post_median[-(npar+1)])
Brier_CRT(MLE_value[-(npar+1)])
Brier_CRT(crt_mle_value)
```

```{r}

Brier_RTG(true_value)
Brier_RTG(post_mean[-(npar+1)])
Brier_RTG(post_median[-(npar+1)])
Brier_RTG(MLE_value[-(npar+1)])
Brier_RTG(crt_mle_value)
```


```{r}

Brier_CO(true_value)
Brier_CO(post_mean[-(npar+1)])
Brier_CO(post_median[-(npar+1)])
Brier_CO(MLE_value[-(npar+1)])
Brier_CO(crt_mle_value)
```




# Out of sample

```{r}
df_test = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0501_test2.csv")
#df_test = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0501_test.csv")
N_test = nrow(df_test)
nAttr = 3
nAlt = 3

X_wide_test = df_test[,3:ncol(df_test)]

tmp_test = sapply(1:N_test,function(x){return(matrix(X_wide_test[x,]))})
tmp_test[,1:5]
X_long_test = t(matrix(tmp,nrow = nAttr,byrow =F))
head(X_long_test)

```



```{r}

RC_test = df_test$chosen
RT_test = df_test$RT

```

```{r}


attrs_test = X_long_test 

# normalized attributes value to [0,1]
attrs_test = sapply(1:nAttr, function(x){(unlist(attrs_test[,x])-min(unlist(attrs_test[,x])))/(max(unlist((attrs_test[,x])))-min(unlist(attrs_test[,x])))})

head(attrs_test)

range(attrs_test)


###
```

```{r}
acc_test= function(est_para1){
  prob = NULL
  for (j in 1:nAlt){

    ############################# CRT/RTG
   #temp = MLBA_rtknown_all(attrs_test,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N), rt = RT_test)
    temp = MLBA_rtg_all(attrs_test,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N), rt = RT_test)
    #temp = RCPPcdf_MLBA_CO_all(attrs_test,beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = est_para1[npar-2] ,lam2 = est_para1[npar-1],  b =est_para1[npar], A =  est_para1[npar]/true_param$b_A, s = true_param$s0, choice = rep(j,N))

    prob = cbind(prob,temp)

  }
  discard = which(prob[,1]==prob[,2])
  #discard = integer(0)
  if(length(discard)==0) {chosen_est = apply(prob, 1, which.max)

  acc = sum(chosen_est==RC_test)/N_test*100}
  else{
    chosen_est = rep(-1,dim(prob)[1])
    chosen_est[-discard] = apply(prob[-discard,], 1, which.max)
  
    
    acc = sum(chosen_est[-discard]==RC_test[-discard])/(N_test-length(discard))*100
  }
  
  return(c(acc,length(discard)))
  
}
```


```{r}
acc_test(true_value)
acc_test(post_mean[-(npar+1)])
acc_test(post_median[-(npar+1)])
acc_test(MLE_value[-(npar+1)])
acc_test(crt_mle_value)

```

```{r}

Brier_CRT_test = function(para){
  RCPP_brier_CRT(attrs_test,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC_test, rt = RT_test)
}
Brier_RTG_test = function(para){
  RCPP_brier_RTG(attrs_test,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC_test, rt = RT_test)
}
Brier_CO_test = function(para){
  RCPP_brier_CO(attrs_test,beta =para[1:(nAttr)] , zeta = c(para[(nAttr+1):(npar-3)],true_param$zeta[3]), lam1 = para[npar-2] ,lam2 = para[npar-1],  b =para[npar], A =  para[npar]/true_param$b_A, s = true_param$s0, choice = RC_test)
}

```

```{r}
Brier_CRT_test(true_value)
Brier_CRT_test(post_mean[-(npar+1)])
Brier_CRT_test(post_median[-(npar+1)])
Brier_CRT_test(MLE_value[-(npar+1)])
Brier_CRT_test(crt_mle_value)
```

```{r}

Brier_RTG_test(true_value)
Brier_RTG_test(post_mean[-(npar+1)])
Brier_RTG_test(post_median[-(npar+1)])
Brier_RTG_test(MLE_value[-(npar+1)])
Brier_RTG_test(crt_mle_value)
```


```{r}

Brier_CO_test(true_value)
Brier_CO_test(post_mean[-(npar+1)])
Brier_CO_test(post_median[-(npar+1)])
Brier_CO_test(MLE_value[-(npar+1)])
Brier_CO_test(crt_mle_value)
```

# Others

```{r}
# p-p plot based on condition
library(tidyr)
library(dplyr)
df_new = data.frame(df_raw[,1:4], RC = attrs[,1], OC = attrs[,2],DR = attrs[,3],rt = df_raw$rt)
real_p = df_new%>% group_by(Scenario) %>%nest()
df_pp = data.frame(Scenario = NULL,real_prob = NULL, Alt_type = NULL, est_prob = NULL)
est_para1 = post_median[-(npar+1)]#est_MLE[MLE_index,]#post_mean[-(npar+1)]#est_MLE[MLE_index,]


for(i in 1:length(real_p$Scenario)){
  data_tmp =real_p$data[[i]]
  temp_chosen = matrix(data_tmp$chosen,nrow = nAlt) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))

  I0_est =  est_para1[npar-3]           
  
  est_prob = sapply(1:nAlt, function(x){
    #MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],   b = est_para1[npar] , A =  est_para1[npar]+true_param$A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  #discard_index = which(apply(est_prob, 1, sum)<1e-5)
  #discard_index = which((est_prob[,1]==est_prob[,2])& (est_prob[,1]>=est_prob[,3]))
  
  
  
  quantile_est = colMeans(est_prob)
  #if(length(discard_index)!=0){
   # est_choice = apply(est_prob[-discard_index,], 1, which.max)
  #  quantile_est = c((sum(est_choice==1)+length(discard_index)/2)/dim(est_prob)[1],(sum(est_choice==2)+length(discard_index)/2)/dim(est_prob)[1],sum(est_choice==3)/dim(est_prob)[1] )
  #}
  #else{
  #  est_choice = apply(est_prob, 1, which.max)
  #  quantile_est = c(sum(est_choice==1)/dim(est_prob)[1],sum(est_choice==2)/dim(est_prob)[1],sum(est_choice==3)/dim(est_prob)[1] )
  #}
  
  # +length(discard_index)
  df_tmp = data.frame(Scenario = rep(str_sub(real_p$Scenario[i],start = 1,end = 4),nAlt),real_prob = Prob_real, Alt_type = c("competitor","target", "decoy" ), est_prob =  quantile_est,ratio = rep(quantile_est[2]/quantile_est[1], 3))
  
  df_pp = rbind(df_pp,df_tmp)
  
}


df_pp
#write.csv(df_pp,"Df for P-P lab_Attraction_RTG(2)")

#0.4324324/0.4054054	/0.1621622
#0.3896104/0.4935065/0.1168831

#0.4110214/ 0.449456/
```




```{r}
ggplot(data = df_pp)+geom_point(aes(x =real_prob, y = est_prob,shape = Scenario, col = Alt_type ))+
    geom_abline(aes(intercept = 0, slope = 1))+
    labs(title = "P-P plot for Attraction Effect")+
    theme_classic()+
    coord_cartesian(xlim = c(0,1),ylim = c(0,1))
  
```
```{r}
df_new = data.frame(df_raw[,1:4], RC = attrs[,1], OC = attrs[,2],DR = attrs[,3],rt = df_raw$rt)
seq_decoy = seq(from =3 ,to = dim(df_new)[1],by = 3)
df_new = df_new[-seq_decoy,]

real_p = df_new%>% group_by(Scenario) %>%nest()
df_pp2 = data.frame(Scenario = NULL,real_prob = NULL, Alt_type = NULL, est_prob = NULL)
est_para1 = post_median


for(i in 1:length(real_p$Scenario)){
  data_tmp =real_p$data[[i]]
  
  temp_chosen = matrix(data_tmp$chosen,nrow = 2) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))

  I0_est =  est_para1[npar-3]           
  #est_prob = sapply(1:nAlt, function(x){MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  est_prob = sapply(1:2, function(x){MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 2))[,1])} )
  
  #discard_index = which(apply(est_prob, 1, sum)<1e-5)
 
  #discard_index = which(sapply(1:dim(est_prob)[1], function(i){est_prob[i,1]==est_prob[i,2]}))
  #est_choice = apply(est_prob[-discard_index,], 1, which.max)
  
  
  
  
  #quantile_est = c((sum(est_choice==1)+length(discard_index)/2)/dim(est_prob)[1],(sum(est_choice==2)+length(discard_index)/2)/dim(est_prob)[1] )
  quantile_est = colMeans(est_prob)
  
  

  df_tmp = data.frame(Scenario = rep(str_sub(real_p$Scenario[i],start = 1,end = 4),2),real_prob = Prob_real, Alt_type = c("competitor","target" ), est_prob =  quantile_est, ratio = rep(quantile_est[2]/quantile_est[1],2))
  
  df_pp2 = rbind(df_pp2,df_tmp)
  
}


df_pp2[which((df_pp2$est_prob!=0 )& (df_pp2$est_prob!=1 )),]

```


```{r}

d_est = sapply(1:nAlt,function(i){sapply(1:N, function(x){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),], beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = est_para1[npar-3], choice = i)})})

#d_real = sapply(1:N, function(x){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 =true_param$lam1 ,lam2 = true_param$lam2,  I0 = true_param$I0,choice = df$chosen[x])}) 

#data.frame(d_est,d_real)

#sum(d_est<d_real)
head(d_est)
sum(rowSums(d_est)==0)

# all d_est is lower estimated, So does d. Therefore, I0 and d should have some relation
rc = apply(d_est[which((rowSums(d_est)!=0)&(d_est[,1]!=d_est[,2]) ),],1,which.max)
summary(as.factor(rc))
# 351 253 

```


## Plot
### The pdf of three alternatives (overlapped version) over RT 

index = 1 & index = 2


```{r}
library(ggplot2)

rt = seq(from = 0, to = 8, length.out = 5e2)

line1 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[1:nAlt,], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt+1):(2*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line2_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt*74+1):(75*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)



RT = matrix(replicate(3*nAlt,rt),ncol = 1)

pdf = c(line1,line2,line2_2)
Alt = c(matrix(t(replicate(5e2, c("Alt1","Alt2","Alt3"))),ncol = 1),matrix(t(replicate(5e2, c("Alt1","Alt2","Alt3"))),ncol = 1),matrix(t(replicate(5e2, c("Alt1","Alt2","Alt3"))),ncol = 1))
Obs = matrix(t(replicate(3*5e2, c("Obs1","Obs2", "Obs75"))),ncol = 1)
Real = rep("True",3*nAlt*5e2)


df_plot =data.frame(RT = RT, pdf = pdf, Alt = Alt, Obs = Obs, Real = Real)
#"#2F334B""#669157" "#7A84B5"

# Obs1
ggplot(df_plot)+geom_line(mapping = aes(x = RT, y = pdf, color = Alt), alpha = 1, linewidth = 1, linetype = "3313")+
  theme_bw() +  
  labs( x = "Response time", y = "pdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(rows = vars(Obs))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
  


```


### The cdf of three alternatives (stacked version) over RT

```{r}


line3 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[1:nAlt,], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line4 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(nAlt+1):(2*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line4_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(nAlt*74+1):(75*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, b = true_param$b,A = true_param$A, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)





cdf = c(line3,line4,line4_2)


df_plot$cdf = cdf
#head(df_plot)


# Obs1
ggplot(df_plot)+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha = 0.5, position = position_dodge(width = 0))+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(rows = vars(Obs))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
  
ggplot(df_plot)+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha =0.7, position = "stack")+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(rows = vars(Obs))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
```

```{r}
# The drift rate

d = sapply(c(1,2,75),function(o){temp = sapply(1:3, function(x){ RCPPdriftmean(X = attrs[((o-1)*nAlt+1):(o*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 = true_param$lam1, lam2 = true_param$lam2,I0 = true_param$I0, choice = x)}); return(temp)}) 
colnames(d) = c("Obs1", "Obs2", "Obs75")
rownames(d) = c("Alt1","Alt2","Alt3")
d = cbind(t(d), chosen = df$chosen[1:3])
d
```


### Comparision it with the estimated version 
index 1 and index 2

```{r}
line5 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[1:nAlt,],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)
                                                                                      
line6 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt+1):(2*nAlt),],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)
line6_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt*74+1):(75*nAlt),],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)

line7 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[1:nAlt,], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line8 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(nAlt+1):(2*nAlt),], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line8_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(74*nAlt+1):(75*nAlt),], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

pdf = c(line5,line6, line6_2)
cdf = c(line7,line8, line8_2)

Real = rep("Est_MLE",3*nAlt*5e2)


temp =data.frame(RT = RT, pdf = pdf, Alt = Alt, Obs = Obs, Real = Real, cdf = cdf)


df_plot_1 = rbind(df_plot, temp)

```


```{r}
ggplot(df_plot_1 )+geom_line(mapping = aes(x = RT, y = pdf, color = Alt), alpha = 1, linewidth = 1, linetype = "3313")+
  theme_bw() +  
  labs( x = "Response time", y = "pdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real),scales = "free")+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
```
```{r}
ggplot(df_plot_1 )+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha =0.5, position = position_dodge(width = 0))+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
  
ggplot(df_plot_1 )+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha =0.7, position = "stack")+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
```


### Contour plot (pairs of chains, with true value)


```{r}
df_contour = data.frame(t(post))#[,-(npar+1)]
 #name1
#name1 = c(expression(beta[RC]),expression(beta[OC]),expression(beta[DR]),expression(zeta[ICEV]),expression(zeta[EVA]),
          #expression(zeta[EVB]),
#          expression(I0),
#          expression(lambda[1]),expression(lambda[2]),"b","LLK")



name1 = c(expression(beta[A]),expression(beta[B]),expression(beta[C]),expression(zeta[1]),expression(zeta[2]),
          #expression(zeta[EVB]),
          expression(I[0]),
          expression(lambda[1]),expression(lambda[2]),"b","LLK")

colnames(df_contour) = name1#c("betaRC","betaOC","betaDR","zeta(ICAEV)", "zeta(EVA)","lam1" ,"lam2" ,"b","llk")
head(df_contour)



#( 3.563 , 49.841 )
#( 0.004 , 23.333 )
#( 1.054 , 11.178 )
#( -3.955 , 3.736 )
#( 1.374 , 4.009 )
#( 0.521 , 1 )
#( 0.05 , 0.374 )
#( 4.965 , 13.383 )


# Set the x-axis range
df_tmp = data.frame(`beta[A]`= c(0,3),`beta[B]`= c(0,7.2),`beta[C]` =c(0,20),`zeta[1]` = c(-2,0),`zeta[2]` = c(-43,-1),
                    `I[0]` = c(0,3),
                    `lambda[1]` = c(0.5,5),`lambda[2]` = c(0,1),`b` = c(6,12),`LLK` = c(-1e3,-1e3))

#df_tmp = data.frame(`beta[RC]`= c(0,25),`beta[OC]`= c(0,50),`beta[DR]` =c(0,15),`zeta[ICEV]` = c(-25,5),`zeta[EVA]` = c(0,4),`lambda[1]` = c(0,1 ),`lambda[2]` = c(0,1),`b` = c(3,15),`LLK` = c(-1e3,-1e3))

#df_tmp = data.frame(`beta[RC]`= c(0,50),`beta[OC]`= c(0,50),`beta[DR]` =c(0,10),`zeta[ICEV]` = c(-4,4),`zeta[EVA]` = c(-1,4),`lambda[1]` = c(0,1 ),`lambda[2]` = c(0,1),`b` = c(3,15),`LLK` = c(-1e3,-1e3))

#colnames(df_tmp) =  name1

#df_contour = rbind(df_contour,df_tmp)
#write.csv(df_contour, "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\simulations\\df_plot_CRTH(9)_May15.csv")
```


```{r}

library(GGally)

# create pairs plot



diag_plot = function(data,mapping,...){

  ggplot(data = data, mapping = mapping )+ 
   geom_histogram(bins = 30, fill = "grey",color = "black", alpha = 0.5)#+
}

lower_plot = function(data,mapping,Lik = df_contour[,(npar+1)],true = true_value,  median =  post_median,...){
 # j<<-  j+1
  ggplot(data = data, mapping = mapping)+
  #ggplot(data = data, mapping = mapping)+
  theme_classic()+labs(x = "",y="")+
  theme(legend.position = "none") + 
  scale_color_gradient(high = "pink", low = "blue")+
  geom_point(aes(color = Lik), alpha = 0.1, cex = 0.1)+
  geom_density2d( color = "#7A84F5")
      
}


plot_canvas = ggpairs( df_contour[,1:npar],
                       diag = list(continuous = wrap(diag_plot, bins = 30)),
                       lower = list(continuous = wrap(lower_plot) ))+
                       theme(plot.margin =unit( c(0.1,0.1,0.1,0.1), "lines")) 
                       
                       
  
#print(plot_canvas)

```



```{r}



plot_all = plot_canvas

k = 2
while(k<=npar){
  j = 1
    while(j<=(k-1)){
      
    plot_all[k,j] = plot_all[k,j]+
      annotate(geom = "point", x = true_value[j], y = true_value[k], shape = 21, size = 2, fill = "#669157")+
      annotate(geom = "point", x = post_median[j], y = post_median[k], shape = 21, size = 2, fill = "blue")+xlim(df_tmp[1,j],df_tmp[2,j])+ylim(df_tmp[1,k],df_tmp[2,k])
   j = j+1
    }
  k = k+1
  
}

yend = c(M/8,M/15,M/6,M/3,M/5,M/4,M/8,M/6,M/3)

for( i in 1:npar){
    plot_all[i,i] = plot_all[i,i]+
    annotate("segment" , x = true_value[i],y = 0,xend = true_value[i] ,yend =yend[i] ,color = "#669157",   linewidth = 1.2)+
    annotate("segment" , x =post_median[i],y = 0,xend =  post_median[i] ,yend =yend[i],color = "blue",   linewidth = 1.2)+labs()+xlim(df_tmp[1,i],df_tmp[2,i])
}
# print(plot_all)
```


### violin
```{r}
library(readr)
post1 = read_csv("post1.csv")
post2 = read_csv("post2.csv")
post3 = read_csv("post3.csv")
head(post1)
post1 = post1[,-c(1,11)]
post1[,1:3] = abs(post1[,1:3])
post2 = post2[,-c(1,11)]
post2[,1:3] = abs(post2[,1:3])
post3 = post3[,-c(1,11)]
post3[,1:3] = abs(post3[,1:3])
post1 = data.frame(post1, type = rep("CRT",dim(post1)[1]))
post2 = data.frame(post2, type = rep("CO",dim(post2)[1]))
post3 = data.frame(post3, type = rep("RTG",dim(post3)[1]))

df = rbind(post1,post2,post3)

colnames(df) = c("betaRC","betaOC","betaDR", "zeta_c", "zeta_t","I0", "lam1","lam2" ,"b","type")
name_df = c("-betaRC","-betaOC","betaDR", "zeta_c", "zeta_t","I0", "lam1","lam2" ,"b","type")
true_value = c(25,1,10,-3,1,1.7,0.1,0.8,20)
head(df)
```



```{r}

library(ggpubr)
library(ggplot2)
#ggarrange

test = list()

i = 1
j = 1
while(i<9){
  if(i>=6) {j = i+1}
  else{j = i}
  
  test[[i]]= ggplot()+
  geom_violin (data = df, aes_(x = df[,10], y = df[,j]),fill = "#7A84F5",color = "white", alpha = 0.5,trim = TRUE)+geom_boxplot(data = df, aes_(x = df[,10], y = df[,j]),outlier.shape = NA,width = 0.04, color = "blue",linewidth = 0.5)+
  geom_point(aes_(x =c("CO","CRT","RTG"), y = rep(true_value[j],3)), fill = "red", shape = 21,size = 3)+
  theme_classic()+
  labs(x = "",y = paste0(name_df[j]))
  i = i+1
}
test[[8]] = test[[8]]+coord_cartesian(ylim = c(0, 50))

ggarrange(plotlist = test, ncol = 3, nrow = 3)
```


