---
title: "MLBARCRT EVs semi-simulated dataset under Hancock model"
author: "Xinwei Li\n li.xinwei@u.nus.edu"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
      highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())


```

# 1. Data import
```{r, echo=FALSE, message=FALSE,results='hide'}
library(tictoc)
library(doParallel)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
library(RcppNumerical)
library(plyr)
library(data.table)
library(readr)
library(crayon)
library(ggplot2)
library(bayestestR)
library(coda)
library(beepr)
file_route = "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\MLBA.cpp"
df = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0801_800.csv")


df_test = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0801_800(test).csv")

sourceCpp(file = file_route)
```

# 2. MLBA prepration
## 2.1 hyperparameter setting

```{r}
true_param = list( lam1 = 1, lam2 = 0.5, zeta = c(0.3,-0.5,1), beta = c(1,2,5), s0 = 1, b = 10, A = 0,alpha = -1,attention = 0, type =1)
sourceCpp(file_route)
nAttr = 3
nAlt = 3
npar = (nAlt-1)+nAttr +2 +0
zeta_index =(nAlt+1):(nAlt+nAttr-1)
```

## 2.2 De-MCMC setup
```{r}

# function to retrive choice-RT and attribute infos from given dataframe
 df_info = function(df){
  res = list()  # four iterms: N;attrs;RC;RT
  # observation number
  res$N = nrow(df)
  # build attrs matrix 
  X_wide = df[,3:ncol(df)]
  tmp = unlist(sapply(1:res$N, function(x){return(matrix(X_wide[x,]))})) 
  X_long = t(matrix(tmp,nrow = nAttr,byrow =F))
  attrs = X_long 
  res$attrs = sapply(1:nAttr, function(x){(unlist(attrs[,x])-min(unlist(attrs[,x])))/(max(unlist((attrs[,x])))-min(unlist(attrs[,x])))})  # normalized attributes value to [0,1]

  # value RT and RC
  res$RC = df$chosen; res$RT = df$RT
  return(res)
}

##########################################
# self-designed parameter transformation 
para_fun=function(para){
  current_para_list = list()
  current_para_list$beta = para[1:nAttr]
  current_para_list$zeta = c(para[(nAttr+1)]+true_param$zeta[nAlt],para[(nAttr+2)]+true_param$zeta[nAlt],+true_param$zeta[nAlt])
  current_para_list$lam1 = para[npar-1]
  current_para_list$lam2 = para[npar]
  current_para_list$A = true_param$A
  current_para_list$b = true_param$b+true_param$A
  current_para_list$s0 =true_param$s0
  return(current_para_list)
}

###########################################################
# function to return the log-posterior of given parameter
poster = function(para_list){
  
  para = as.numeric(para_list$para)
  type = para_list$type
  prior = rep(-1,length(para))
  
  prior[zeta_index] = dunif(para[zeta_index], min = -100, max = 100,log = T)
  prior[-zeta_index] = dunif(para[-zeta_index], min = 0, max = 200,log = T)
  #prior[-zeta_index] = dunif(para[-zeta_index], min = -3, max = 7,log = T)
  prior[(npar-1):npar] =  dunif(para[(npar-1):(npar)], min = 0, max = 5,log = T)
  # prior[(npar-2):(npar-1)] = dunif(para[(npar-2):(npar-1)], min = 0, max = 5,log = T)
  #prior[(npar-1)] = dunif(para[(npar-1)], min = 0, max = 5,log = T)
  #prior[npar] = dunif(para[npar], min = 0, max = 1,log = T)
 
  
  para_tmp = para_fun(para = para)
  
if(type=="CRT"){
 temp = sum(prior) +  RCPPMLBA_Lik_rtknown(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
   
}else if(type=="RTG"){
  temp = sum(prior) +  RCPPMLBA_Lik_rtg(X = attrs,beta = para_tmp$beta, zeta = para_tmp $zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
    
}else{
  temp = sum(prior) + RCPPMLBA_Lik_CO(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC)
    
}
  if(is.na(temp)) temp = -Inf
  
  return (temp)
}
############################################
# initial function
chain_intial = function(type0,K,npar){
# initialize chains. the last column is for likelihood
chain_int = matrix(nrow = K, ncol = npar+1)
chain_list = list()
theta_0 = chain_int

  theta_0[,zeta_index] = runif(K*length(zeta_index), min = -100, max = 100)
  theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 200)
  theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 5)

theta_0[,(npar+1)] = sapply(1:K, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0) ))})

# check whether All Likelihood is smaller than Inf
index = which(is.infinite(theta_0[,(npar+1)]))

while (length(index)) {
  
  theta_0[index,zeta_index] = runif(length(index)*length(zeta_index), min =-100, max = 100)
  theta_0[index,-c(zeta_index,npar+1)] = runif(length(index)*(npar-length(zeta_index)), min = 0, max = 200)
  theta_0[index,(npar-1):(npar)] = runif(length(index)*2, min = 0 , max = 5)
  

  theta_0[index,(npar+1)] = sapply(index, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0)))})
  index = which(is.infinite(theta_0[,(npar+1)]))

  # print(paste("Still has", length(index), "to find."))
}
chain_list[[1]] = theta_0

return(chain_list)
}

###########################################
# cross-over step
Update_para = function(para){
  # para = list(ChainIndex,last_chainlist,gamma)
  # last_chainlist is a matrix each row means the last step value of each chain and the last column is the liklihood of the corresponding parameters
 
  theta_prev = para$last_chain[para$ChainIndex,-(npar+1)]
  # randomly draw two chain from all chains except current chain
  de_ChainIndex = sample(probset[-para$ChainIndex], size = 2,replace = FALSE)
  theta_m = para$last_chain[de_ChainIndex[1],-(npar+1)] 
  theta_n = para$last_chain[de_ChainIndex[2],-(npar+1)] 
  # generate new theta, the here are 6 parameters to estimate in total
  add = runif(npar, min = -0.05, max = 0.05)#npar
  theta_new = theta_prev + para$gamma* (theta_m - theta_n) + add
  
  new_post = poster(para_list = list(para = theta_new, type = type0) )
  prev_post = para$last_chain[para$ChainIndex,(npar+1)]

  # accept rate
  alpha = runif(1)
  
  ratio = exp(new_post-prev_post)
  #if(is.na(ratio)) ratio = 0
  if( alpha> ratio) temp = c(theta_prev,prev_post) else temp = c(theta_new,new_post)
    
  
  return(temp)
}
######################################### 
## update chains
De_MCMC_unit = function(prev, X, gam1){
  
  para = list(ChainIndex = X, last_chain = prev, gamma = gam1)#runif(1,.5,1)
  Update_para(para)
}

#########################################
# migrate step
migrate_step = function(current_chain_list){
    temp_ssize = ceiling(runif(1,min = 1, max = K))
    temp_sample =sample(1:K,temp_ssize,replace = FALSE)
    
    theta_res = current_chain_list[temp_sample[1],]
    for (g in 1:temp_ssize){
     temp_theta = current_chain_list[temp_sample[g],-(npar+1)]
     add = runif(npar, min = -0.05, max = 0.05)#npar
    
      if(g==1) new_theta = current_chain_list[temp_sample[temp_ssize],-(npar+1)] +add
     # previous item 
      else  new_theta = theta_res[-(npar+1)] + add
     
      new_post = poster(para_list = list(para = new_theta, type = type0))
      prev_post = theta_res[(npar+1)]
      theta_res = current_chain_list[temp_sample[g],]
      
      alpha = runif(1)
      ratio = exp(new_post-prev_post)
      #if(is.na(ratio)) ratio = 0
      if(alpha<ratio)  current_chain_list[temp_sample[g],] = c(new_theta,new_post)
    }
    
    return(current_chain_list)
}
###########################################
# parall_computing

demcmc_fun = function(chain_list, burn_in, M, mig_rate, type0, probset, K, N, npar, RC, RT, attrs,version,continuous = 0){
  
for (j in (1+continuous):(M+continuous)) {

  chain_list[[j+1]] = t(parSapply(X = 1:K, FUN = De_MCMC_unit, prev = chain_list[[j]], gam1 = gam, cl = cl))
  
  # immigration step (only works at certain steps at early stage)
  if ((j<round(continuous+burn_in*0.75))&(runif(1)<mig_rate)){
chain_list[[j+1]] = migrate_step(current_chain_list = chain_list[[j+1]])}
  if(type0=="CO"){
    if(j%%1e2==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  else{
    if(j%%1e3==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  
  if(j%%1000==0) {saveRDS(chain_list, file = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep=""))}
  } 
  
return(list(chain_list=chain_list,path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")))
}
########################################
# result generation
result_fun = function(type0, N, attrs,version){
  set.seed(2025)
  path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) #RTG 200

  est1 = sapply(chain_all[thin], colMeans)
  est2 = sapply(chain_all, function(x){apply(x,2,sd)})
  est3 = sapply(chain_all[thin], function(x){apply(x, 2, median)})
  est3[zeta_index,] = est3[zeta_index,] +true_param$zeta[3]
  est_median = est3

  true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               poster(para_list = list(para = 
                      c(true_param$beta,
                        true_param$zeta[-3]-true_param$zeta[3],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0)))
  true_value_v2 = true_value
  true_value_v2[zeta_index] =true_value_v2[zeta_index] -true_param$zeta[nAlt]
  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
    post_mcerror[j] =sd(post[j,])/sqrt(2*effectiveSize(post[j,]))
    post_mse[j] = sqrt(mean((post[j,]-true_value_v2[j])^2))
  }
  #Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  
  post_mean = apply(post,1, mean)
  post_mean[npar+1] = poster(para_list = list(para = post_mean[-(npar+1)],type = type0))
  post_mean[zeta_index] = post_mean[zeta_index]+true_param$zeta[3]
    
  post_median = apply(post , 1, median)
  post_median[npar+1] = poster(para_list = list(para = post_median[-(npar+1)],type = type0))
  post_median[zeta_index] = post_median[zeta_index]+true_param$zeta[3]
  
  post[zeta_index,] = post[zeta_index,]+true_param$zeta[3]
  Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  name = c("betaA","betaB","betaC", "zeta1","zeta2", "lam1", "lam2" ,"Lik")
  
  HDI_para = apply(post, 1,function(x){temp = hdi(x, ci = 0.95, verbose = FALSE); return (c(temp$CI_low, temp$CI_high))},simplify = TRUE)
  MLE_value[zeta_index] = MLE_value[zeta_index]+true_param$zeta[3]
  result4 = data.frame( true =true_value,
                        est_mean = round(post_mean,3),
                        est_median = round(post_median,3), 
                        sd = round(post_sd,3),
                        hdi_95 = c(sapply(1:npar, function(x){paste("( ", round(t(HDI_para)[x,1],3),", ",round(t(HDI_para)[x,2],3),")")}),"-"),
                        mse = round(post_mse,3),
                        MLE = round(est_MLE[MLE_index,],3))#,
                        #mcmc_error = post_mcerror)
                        #bias = sapply(round((est_MLE[MLE_index,]-true_value)/true_value*100,2), function(x){paste(x,"%")}))
  post_app = rep(NULL,npar+1)
  rownames(result4) = name
  write.csv(post,paste("Post_sim_",N,"_",type0,"Aug_",version, ".csv",sep=""))
  return(result4)
  write.csv(result4,paste0(type0,"_post_",N,version,".rds",".csv",step = ""))
}


```

## 2.3 MLE setup
```{r}
library(optimParallel)
##############################
# likelihood function
LL = function(para,type0){
  temp = poster(para_list = list(para = para, type0 = type0))#-log(1/200)*(npar-2)-log(1/5)*2
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}

gn = function(para,type0){
  para_list = para_fun(para = para)
 if(type0=="CRT"){
   temp = score_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = score_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = score_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
  # temp = numDeriv::grad(func = LL1,x = para)
  # temp = temp[-(nAttr+nAlt-1+2-1)]
  for(tempi in 1:length(temp)){
    if(is.na(temp[tempi])) temp[tempi] = 0
  if(is.infinite(temp[tempi])) {
    if(temp[tempi]>0) {temp[tempi] = 1e6}
    else {temp[tempi] = -1e6}
  }
    }
  return(temp)
}

gnBHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = t(sapply(1:N, function(x){score_mlba_crt_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else if (type0 == "RTG"){
   temp = t(sapply(1:N, function(x){score_mlba_rtg_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else{
   temp = t(sapply(1:N, function(x){score_mlba_co_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x])}))
 }
  return(temp)
}

Hessian_BHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = derivative_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = derivative_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = derivative_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
 for(tmpi in 1:dim(temp)[1]){
   for(tmpj in 1:dim(temp)[2]){
     if(is.na(temp[tmpi,tmpj])) temp[tmpi,tmpj] = 0
     else if (is.infinite(temp[tmpi,tmpj])) {
       if(temp[tmpi,tmpj>0]) temp[tmpi,tmpj]=1e6
       else temp[tmpi,tmpj]=-1e6
     }
     
     }}
 
  return(temp)
}
#########################
mle_fun = function(type0, N, attrs, npar, RC, RT, try_times, MAP_value,Mean_value,Median_value,L_vec,cl,pgtol,version){
  # set up mle
  set.seed(2025)
  est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = try_times)
  mle1_list_adj_v1 = list()
  mle1_list_sd_v1 = list()
  i = 1;k = 1
 
  while(i<=try_times){
      if(k==1){
        par_value = MAP_value
      }
      else if(k==2) {
        par_value = Mean_value
      }
    else if(k==3) {
        par_value = Median_value
      }
      else {
      tmp_alpha = runif(1)
      tmpt_value = ifelse(tmp_alpha<0.5,ifelse(tmp_alpha<0.2,Mean_value,Median_value),MAP_value)
      tmpt_value = MAP_value
      if(k<50){
        
       noise = runif(npar,min = -1,max = 1)
      noise[(npar-1):(npar)] =  runif(2,min = - 0.1,max = 0.1) 
      }else if (k<100){
        if(k==51) message("has tried 50 different initial values.")
        noise = runif(npar,min = -5,max = 5)
      noise[(npar-1):(npar)] =  runif(2,min = - 0.5,max = 0.5) 
      }else{
        if(k==101) message("has tried 100 different initial values.")
        noise = runif(npar,min = -10,max = 10)
      noise[(npar-1):(npar)] =  runif(2,min = - 1,max = 1) 
      }
      
      
      par_value = tmpt_value + noise  
      par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(max(x,0))})
      par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(min(x,200))})
      par_value[c(npar-1,npar)] = sapply(par_value[c(npar-1,npar)],function(x){return(max(x,0))})
      par_value[c(npar-1,npar)] = sapply(par_value[c(npar-1,npar)],function(x){return(min(x,5))})
      
      
    }
  OK = tryCatch(
    { k = k+1
      mle1 = optimParallel(par = par_value,
      fn = LL1, gr = gn1, 
      method = "L-BFGS-B",
      lower = c(0,0,0,-100,-100,0,0), #7
      upper = c(200,200,200,100,100,5,5), #7
      control = list(fnscale = -1,#maxit = 1e4,
                     # ndeps = c(1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3),
                     #pgtol = pgtol,
                     trace = 0),
      # hessian = ifelse(type0=="CO",TRUE,FALSE),
        # TRUE,
                     #pgtol = 1e-3*npar),
      parallel = list(cl=cl))
if(k==2){message(paste("The MLE estimation of ",type0," with " ,N, " has started:",sep=""))
  # message(mle1)
  }
if(is.na(mle1$convergence)) {FALSE}
else{
  if (mle1$convergence!= 0) {FALSE}
else{
    w_matrix = L_vec%*%Hessian_BHHH(para = as.numeric(mle1$par),type0 = type0)%*%t(L_vec)
  if(det(w_matrix)==0){
    flag = 0
   
  }else{
    sd.hat = tryCatch(sqrt(diag(solve(-w_matrix))),error =function(e) {NA},warning =function(w){NA} )
 
    flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat)))
    
  }
   
  if(flag){
    mle1_list_adj_v1[[i]] = mle1 
    mle1_list_sd_v1[[i]] = sd.hat
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    
    TRUE
    }else{FALSE}
    
    }
}

    },
  error=function(e){return(FALSE)})
  if (OK){
    if (type0=="CO"){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
      if(i%%5==0){
        saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
      }}
    else if (i%%3 ==0){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
    }
  
    i = i+1 } else {next}
  
  if(k==250){
    message("200 attempts have been made. quite the process now")
  break}
  }

  
  
  saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))

  }
#########################

#######################
result_mle_fun = function( type0, N, attrs, npar, RC, RT,try_times,L_vec,pgtol,version ){
    true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               LL(para = 
                      c(true_param$beta,
                        true_param$zeta[-nAlt]-true_param$zeta[nAlt],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0))
  est_mle1_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_sd_v1 = readRDS(file =  paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))

# tol_check = sapply(1:try_times,function(tryi){tmp = max(gn1(est_mle1_adj_v1[-(npar+1),tryi])/N);ifelse(tmp<=pgtol,1,Inf)})

tol_check = rep(1,try_times)


index = which.max(est_mle1_adj_v1[(npar+1),]*tol_check)
crt_para = est_mle1_adj_v1[,index]
crt_para[zeta_index] = crt_para[zeta_index]+true_param$zeta[nAlt]
crt_mle = mle1_list_adj_v1[[index]]
crt_mle_value = crt_para
res_mle = data.frame(true = true_value,est =round(crt_para,3),se = c(round(mle1_list_sd_v1[[index]],3),"-"),gr =c( gn1(est_mle1_adj_v1[-(npar+1),index])/N,"-"),eigen_value = round(c(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value,max(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index], type0 = type0)%*%t(L_vec)))$value)/min(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value)),3))
return(res_mle)
}

```


# 3. MLBA Estimation
## 3.1 Bayesian estimation by De-MCMC
```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
K = npar*3; M = 8e3; burn_in = 4e3;mig_rate = 0.3; gam = 2.38/sqrt(2*npar);probset = 1:K  

# CRT 6e3; 3e3;0.35 for all
# RTG 6e3; 3e3;0.35 for [11,14,17,20];0.7 for [2,5,8];


# CO 6e3; 3e3;0.35 for all; 9e3; 4e3;0.25 for [6,9,15,21]; 8e3; 4e3;0.3 for [18]
############################### parallel computing setup
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
numCores = min(K,detectCores()-2)
# use enough cores to do parallel computation ,but not overload CPU
cl = makeCluster(numCores) 
# registerDoParallel(cl=cl)
# settings for parallel computing
clusterEvalQ(cl=cl, {library("doParallel");library("parallel");library("foreach");library("Rcpp");library("RcppArmadillo");library("truncnorm");library("RcppNumerical")})

clusterExport(cl = cl, c("file_route","true_param", "De_MCMC_unit", "poster", "Update_para", "K","gam", "npar",  "nAlt", "zeta_index" ,"nAttr", "para_fun", "migrate_step","probset"), envir = .GlobalEnv) 
clusterEvalQ(cl=cl, sourceCpp(file_route))

########################################
m = 1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
    
clusterExport(cl = cl, c("N", "RT", "RC", "type0","attrs"), envir = .GlobalEnv)

chain_list = chain_intial(type0=type0, K = K,npar = npar)

# chain_list = readRDS(file = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep=""))
chain_list = demcmc_fun(chain_list = chain_list, burn_in = burn_in,
                        mig_rate = mig_rate, type0 = type0, K = K, N=N,
                        npar = npar,RC = RC, RT = RT, attrs = attrs,probset = probset,M = M, version = version,continuous = 0)
toc()
    }
    m = m+1
  }
}

stopCluster(cl=cl);doParallel::stopImplicitCluster()
```



```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
result_table = list()
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

    result_table[[m]] = result_fun(type0 = type0,N = N, attrs = attrs,version = version)
    print(paste(N, "of MLBA",type0,"result has been printed.",sep = " "))
    m = m+1
  }}


saveRDS(result_table,paste("Result_table_bayesian_",version,".rds",sep=""))

```

```{r}
beep(sound=8)
```

## 3.2. MLE estimation
```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO") 
version = "v2"

try_times = 30; max_index = nAttr+nAlt-1+2+1; L_vec = diag(1,nrow = max_index-1,ncol = max_index); pgtol = 1e-3;

#####################
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
# parallel estimation set up
numCores = detectCores()-1
# numCores = min(1+2*npar,detectCores()-2)  
# set the number of processor cores
cl = parallel::makeCluster(numCores) 
parallel::clusterEvalQ(cl, {
  # Optional: keep each worker single-threaded to avoid nested threading
  Sys.setenv(OMP_NUM_THREADS="1", OPENBLAS_NUM_THREADS="1", MKL_NUM_THREADS="1",
             VECLIB_MAXIMUM_THREADS="1", NUMEXPR_NUM_THREADS="1")
  if (requireNamespace("RhpcBLASctl", quietly = TRUE)) {
    RhpcBLASctl::blas_set_num_threads(1)
    RhpcBLASctl::omp_set_num_threads(1)
  }
  NULL
})

parallel::clusterEvalQ(cl = cl, {library(Rcpp); library(RcppArmadillo); library(truncnorm); library(RcppNumerical); library(numDeriv);})
clusterExport(cl = cl, c("file_route","true_param", "npar",  "nAlt","zeta_index" ,"nAttr", "df", "LL","gn","poster","para_fun","L_vec","max_index"), envir = .GlobalEnv)
clusterEvalQ(cl = cl, sourceCpp(file_route))
message("The parallel setting has been done.")
#####################
  

result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep = "") )
mle_res_table = list()

m = 1

for(sample_size in sample_size_set){
  for(type0 in type_set){
    # if(m%in%c(1,4,7,10,13,16,19)){
    # if(m%in%c(2,5,8,11,14,17,20)){
    if(m%in%c(18)){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
  LL1 = function(para) LL(para = para, type0 = type0)
gn1 = function(para) L_vec %*% gn(para = para, type0 = type0)
  MAP_value = result_table[[m]]$MLE[-(npar+1)]
  MAP_value[zeta_index] = MAP_value[zeta_index]-true_param$zeta[nAlt]
  Mean_value =result_table[[m]]$est_mean[-(npar+1)]
  Mean_value[zeta_index] = Mean_value[zeta_index]-true_param$zeta[nAlt]
  Median_value =result_table[[m]]$est_median[-(npar+1)]
  Median_value[zeta_index] = Median_value[zeta_index]-true_param$zeta[nAlt]
  
  parallel::clusterExport(cl = cl,
  c("type0","N","attrs","RC","RT","MAP_value","LL1","gn1"),envir = environment())

  mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, MAP_value = MAP_value,Mean_value = Mean_value,Median_value = Median_value, L_vec = L_vec, cl = cl, pgtol = pgtol,version = version)
  toc()
}
  m = m+1
  }
  }
  
  


stopCluster(cl=cl);doParallel::stopImplicitCluster()
# 6119.86 sec CO 30;800  #440.67 sec CRT 30-50; 14483.71 sec for CO 600
```

```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
try_times = 30; max_index = nAttr+nAlt-1+2+1;L_vec = diag(1,nrow = max_index-1,ncol = max_index);pgtol = 1e-2;
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep=""))
mle_res_table = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    LL1 = function(para){
    return(LL(para = para,type0 = type0))
  }
    gn1 = function(para){
      temp = gn(para = para,type0 = type0)
      res =  L_vec%*%temp 
    return(res)
    }
   
   
mle_res_table[[m]] = result_mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, L_vec = L_vec, pgtol = pgtol,version = version)
m = m+1
  }}


saveRDS(mle_res_table,paste("Result_table_mle_",version,".rds",sep=""))
```

## 4. Accuracy Calculation
```{r}
acc= function(para,type0,RC,RT,attrs,N){
  prob = NULL
  for (j in 1:nAlt){
  para_list = para_fun(para = para)
  if(type0=="CRT"){
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))
  }else if(type0=="RTG"){
    temp = MLBA_rtg_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N), rt = RT)
  }else{
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))}
  prob = cbind(prob,temp)
  }
  
  prob_brier = t(apply(prob,1,function(x){return(x/sum(x))}))
  tmp = matrix(0,ncol = nAlt, nrow = N)
  for( i in 1:N){
    tmp[i,RC[i]] = 1
  }

  brier = sum((tmp-prob_brier)**2)/N 
    
  discard = which((prob[,1]==prob[,2])|(prob[,3]==prob[,2])|(prob[,1]==prob[,3]))
  #discard = integer(0)
  if(length(discard)==0) {chosen_est = apply(prob, 1, which.max)

  acc = sum(chosen_est==RC)/N*100}
  else{
    chosen_est = rep(-1,dim(prob)[1])
    chosen_est[-discard] = apply(prob[-discard,], 1, which.max)

    acc = sum(chosen_est[-discard]==RC[-discard])/(N-length(discard))*100
  }
  
  
  
  
  
  return(list(acc = round(acc,1),brier = round(brier,3),dis = length(discard)))

}
```

```{r}
# acc table generation
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep=""))
result_mle_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))

acc_res_table = list()
m=1
acc_res_table$acc = list()
acc_res_table$brier= list()
for(sample_size in sample_size_set){
  # training set
  basic_Info = df_info(df = df[1:sample_size,])
  N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
  # test set
  basic_Info_test = df_info(df = df_test[1:sample_size,])
  N_test = basic_Info_test$N;attrs_test = basic_Info_test$attrs; RT_test = basic_Info_test$RT; RC_test = basic_Info_test$RC;
  
  # acc
  
  mean_b_crt = result_table[[(m-1)*length(type_set)+1]]$est_mean[-(npar+1)]
  mean_b_crt[zeta_index] = mean_b_crt[zeta_index]-true_param$zeta[nAlt]
  mle_crt = result_mle_table[[(m-1)*length(type_set)+1]]$est[-(npar+1)]
  mle_crt[zeta_index] = mle_crt[zeta_index]-true_param$zeta[nAlt]
  
  mean_b_rtg = result_table[[(m-1)*length(type_set)+2]]$est_mean[-(npar+1)]
  mean_b_rtg[zeta_index] = mean_b_rtg[zeta_index]-true_param$zeta[nAlt]
  mle_rtg = result_mle_table[[(m-1)*length(type_set)+2]]$est[-(npar+1)]
  mle_rtg[zeta_index] = mle_rtg[zeta_index]-true_param$zeta[nAlt]
  
  mean_b_co = result_table[[m*length(type_set)]]$est_mean[-(npar+1)]
  mean_b_co[zeta_index] = mean_b_co[zeta_index]-true_param$zeta[nAlt]
  mle_co = result_mle_table[[m*length(type_set)]]$est[-(npar+1)]
  mle_co[zeta_index] = mle_co[zeta_index]-true_param$zeta[nAlt]
  # true_value_v2 = true_value[-(npar+1)]
  # true_value_v2[zeta_index] = true_value_v2[zeta_index]-true_param$zeta[nAlt]
  acc_res_table$acc[[m]] = data.frame(size = rep(sample_size,length(type_set)),
                                      models = type_set,
                                      acc_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mean_b_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$acc),
                                      acc_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mle_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$acc),
                                      acc_os_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mean_b_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mean_b_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc),
                                      acc_os_mle = c(acc(para = mle_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mle_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mle_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc))
  
  # brier
  acc_res_table$brier[[m]] = data.frame(size = rep(sample_size,length(type_set)),
                                        models = type_set,
                                        brier_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mean_b_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$brier),
                                      brier_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mle_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$brier),
                                      brier_os_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mean_b_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mean_b_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier),
                                      brier_os_mle = c(acc(para = mle_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mle_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mle_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier))  
    
   m = m+1 
  
}
acc_table = rbindlist(acc_res_table$acc)
brier_table = rbindlist(acc_res_table$brier)

version = "v3"
saveRDS(acc_table,paste("acc_table_",version,".rds",sep=""))
saveRDS(brier_table,paste("brier_table_",version,".rds",sep=""))


print(acc_table);print(brier_table)
```



# 5. Plots
## 5.1 violon plot

```{r,warning=FALSE}
# posterior dataset generation
sample_size_set = c(50,80,100,200,400,600,800)
version = "v2"
post_list = list()
m = 1
for(sample_size in sample_size_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
 
  post_crt = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","CRT","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

  post_rtg = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","RTG","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

  post_co = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","CO","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

name1 = c(bquote(beta[A]~", "~.(sample_size)), bquote(beta[B]~", "~.(sample_size)), bquote(beta[C]~", "~.(sample_size)), bquote(zeta[1]~", "~.(sample_size)),bquote(zeta[2]~", "~.(sample_size)),bquote(lambda[1]~", "~.(sample_size)),bquote(lambda[2]~", "~.(sample_size)),"LLK")
post_crt = t(post_crt[,-1])
post_rtg = t(post_rtg[,-1])
post_co = t(post_co[,-1])
post_crt = data.frame(post_crt, type = rep("CRT",dim(post_crt)[1]))
post_rtg = data.frame(post_rtg, type = rep("RTG",dim(post_rtg)[1]))
post_co = data.frame(post_co, type = rep("CO",dim(post_co)[1]))
df_tmp = rbind(post_crt,post_rtg,post_co)
colnames(df_tmp) =c(name1,"type")
name_df = c(name1[-(npar+1)],"type")
post_list[[m]] = df_tmp
print(paste("Posteriors for observations whose size is", sample_size_set[m],"has been generated."))
m = m+1

}

saveRDS(post_list,file = paste("df_violin_sim_3type_Aug",version,".rds",sep = ""))

```

```{r}
# MLE dataset generation
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
name = c("betaA","betaB","betaC","zeta1","zeta2","lam1","lam2")
version = "v2"
mle_res_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))
MLE_df_tmp = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    MLE_df_tmp[[m]] = data.frame(param = name, est = mle_res_table[[m]]$est[-(npar+1)],  se = as.numeric(mle_res_table[[m]]$se[-(npar+1)]), type = rep(type0,npar),  size     = rep(N,npar), Lo = round(mle_res_table[[m]]$est[-(npar+1)]+as.numeric(mle_res_table[[m]]$se[-(npar+1)])*qnorm(0.025),3),   Up = round(mle_res_table[[m]]$est[-(npar+1)]+as.numeric(mle_res_table[[m]]$se[-(npar+1)])*qnorm(0.975),3))
   m = m+1 
  }}
MLE_df  = rbindlist(MLE_df_tmp)

MLE_df$Lo = sapply(1:nrow(MLE_df),function(i){
  if(!MLE_df$param[i]%in%c("zeta1","zeta2")){return(max(0,MLE_df$Lo[i]))}else{return(MLE_df$Lo[i])}})
MLE_df$Up = sapply(1:nrow(MLE_df),function(i){
  if(MLE_df$param[i]%in%c("betaA","betaB","betaC")){return(min(200,MLE_df$Up[i]))}else if(MLE_df$param[i]%in%c("lam1","lam2")){
    return(min(5,MLE_df$Up[i]))}else{return(MLE_df$Up[i])}})
head(MLE_df)

saveRDS(MLE_df,file = paste("df_violin_sim_3type_mle_Aug_",version,".rds",sep=""))
```


```{r}

true_value_sd = matrix(c(0,8,0,22,0,51.5,-3.8,4.4,-6.5,6.5,0,5.1,0,2.5),nrow = 2) # the y-axis boundary of plot

########### for partial sample sizes
# MLE_df_sub = MLE_df[which(MLE_df$size%in%c(50,100,200,400,600,800)),]
# sample_size_set_sub = c(200,400,600,800)

############ for all sample sizes
MLE_df_sub = MLE_df
sample_size_set_sub = sample_size_set
  
true_value_sd[1,] = sapply(1:npar,function(x){tmp = matrix(MLE_df_sub$Lo,nrow = 3*length(sample_size_set_sub),byrow = T);return(min(tmp[,x])-1)})
true_value_sd[2,] = sapply(1:npar,function(x){tmp = matrix(MLE_df_sub$Up,nrow = 3*length(sample_size_set_sub),byrow = T);return(max(tmp[,x])+1)})
true_value_violin = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2)

```

```{r}

library(ggpubr)
library(ggplot2)
library(ggplotify)


test = list()


m = 1
while (m<=length(sample_size_set)) {
test[[m]] = list()
sample_size = sample_size_set[m]
i = 1
j = 1
while(i<=npar){
  j = i
  MLE_df1 = MLE_df[which(MLE_df$size==sample_size),]
  post_df1 = post_list[[m]]
  res_tmp =data.frame(MLE_df1[seq(from = i,to = npar*3,by =npar),])
  name1 = c(bquote(beta[A]~", "~.(sample_size)), bquote(beta[B]~", "~.(sample_size)), bquote(beta[C]~", "~.(sample_size)), bquote(zeta[1]~", "~.(sample_size)),bquote(zeta[2]~", "~.(sample_size)),bquote(lambda[1]~", "~.(sample_size)),bquote(lambda[2]~", "~.(sample_size)),"LLK")
  
  
  test[[m]][[i]]= ggplot()+geom_violin (data = post_df1, aes_(x = post_df1[,(npar+2)], y = post_df1[,j],fill = "Posterior"), alpha = 1,trim = FALSE,color = "#7A84F5",scale = "width",linewidth = 1)+
    geom_pointrange(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up, fill = "CI"),linewidth =0.5,shape = 24,alpha = 0.8,size =0.5,color = "#669157")+
    geom_errorbar(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up), color = "#669157",linewidth =0.7,width = 0.8,size = 0.8)+
    # geom_hline(aes_(yintercept = true_value[j],color = "TRUE"), linetype = 2,linewidth =1,alpha = 0.6)+
  geom_point(aes_(x =c("CO","CRT","RTG"), y = rep(true_value_violin[j],3), fill = "TRUE"), shape = 21,size = 3,alpha = 0.6,color ="#6d1950")+
  theme_classic()+
  labs(x = "",title = name1[[j]],y = "")+ylim(true_value_sd[1,j],true_value_sd[2,j])+
     theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")+
    scale_fill_manual(values = c("Posterior" = "#C4B5E0", "CI" = "#669157", "TRUE" = "#6d1950"))+
    labs(fill = "")
  i = i+1
}

g = ggplotGrob(test[[m]][[1]])
leg = g$grobs[[which(sapply(g$grobs, `[[`, "name") == "guide-box")]]
test[[m]][[npar+1]] = as.ggplot(leg)
m = m+1

}


saveRDS(test,paste("Plt_violin_sim_Aug_",version,".rds",sep=""))
```

```{r}

for (l in 1:npar){
plt_tmp = ggarrange(plotlist = list(test[[1]][[l]],test[[2]][[l]],test[[3]][[l]],test[[4]][[l]],test[[5]][[l]],test[[6]][[l]],test[[7]][[l]],test[[1]][[npar+1]]),ncol = 4, nrow = 2,common.legend = T,legend = "none")
ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/Full_violin",name[l],"_",version,".pdf",sep=""),
         plot   = plt_tmp ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 6.5, units = "in")
  
  
}


```

```{r}
for (m in 1:length(sample_size_set)){
plt_tmp = ggarrange(plotlist = list(test[[m]][[1]],test[[m]][[2]],test[[m]][[3]],test[[m]][[4]],test[[m]][[5]],test[[m]][[6]],test[[m]][[7]],test[[m]][[npar+1]]),ncol = 4, nrow = 2,common.legend = T,legend = "none")
ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/Full_violin(",sample_size_set[m],")_",version,".pdf",sep=""),
         plot   = plt_tmp ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 6.5, units = "in")
  
  
}
```

## 5.2 MSE plot

```{r}
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep="") )

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
name = c("betaA","betaB","betaC","zeta1","zeta2","lam1","lam2")
MSE_df_tmp = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    
    MSE_df_tmp[[m]] = data.frame(param = name, mse = result_table[[m]]$mse[-(npar+1)], distribution = rep(type0,npar),  size = rep(N,npar),estimate = rep("post",npar))
   m = m+1 
  }}

mle_res_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    tmpt_m =  m-length(sample_size_set)*length(type_set)
    MSE_df_tmp[[m]] = data.frame(param = name, mse = round(sqrt(abs(mle_res_table[[tmpt_m]]$true[-(npar+1)]-mle_res_table[[tmpt_m]]$est[-(npar+1)])^2+as.numeric(mle_res_table[[tmpt_m]]$se[-(npar+1)])^2),3), distribution = rep(type0,npar),  size = rep(N,npar),estimate = rep("mle",npar))
   m = m+1 
  }}


MSE_df  = rbindlist(MSE_df_tmp)

head(MSE_df)
saveRDS(MSE_df,paste("df_sim_3type_mse_Aug_",version,".rds",sep=""))

```




```{r}
library(ggpubr)
library(ggplot2)
library(grid)
# MSE_df$size = as.factor(MSE_df$size)
name_df = c(expression(beta[A]), expression(beta[B]), expression(beta[C]), expression(zeta[1]),expression(zeta[2]),expression(lambda[1]),expression(lambda[2]),"LLK")

test = list()
i = 1
j = 1
while(i<=npar){
 
  j = i
  res_tmp =data.frame(MSE_df[seq(from = i,to = npar*length(sample_size_set)*2*length(type_set),by =npar),])
  
  test[[i]]= ggplot()+
    geom_line(data = res_tmp,aes(x=size,y = log(mse),colour = distribution,linetype = estimate, group = interaction(estimate, distribution)),linewidth = 1.5, alpha = 0.6)+
  theme_classic()+
  labs(x = "",y = "",title = name_df[j])+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")
    
    
  i = i+1
}
test[[1]] = test[[1]] + labs(y = "log(MSE)")
test[[nAttr+1]] = test[[nAttr+1]] + labs(y = "log(MSE)")
test[[npar-1]] = test[[npar-1]] + labs(y = "log(MSE)")

test[[2]] = test[[2]] + labs(x = "sample size")
test[[npar-1]] = test[[npar-1]] + labs(x = "sample size")
test[[npar]] = test[[npar]] + labs(x = "sample size")


library(ggplotify)

g <- ggplotGrob(test[[1]])
leg <- g$grobs[[which(sapply(g$grobs, `[[`, "name") == "guide-box")]]
test[[npar+1]] = as.ggplot(leg)

test[[npar+2]] = ggarrange(plotlist = list(test[[1]],test[[2]],test[[3]]),ncol = 3,nrow =1, common.legend = T,legend = "none")
test[[npar+3]] = ggarrange(plotlist = list(test[[4]],test[[6]]),ncol = 1,nrow =2, common.legend = T,legend = "none")
test[[npar+4]] = ggarrange(plotlist = list(test[[5]],test[[7]]),ncol = 1,nrow =2, common.legend = T,legend = "none")

test[[npar+5]] = ggarrange(plotlist = list(test[[npar+3]],test[[npar+1]],test[[npar+4]]),ncol = 3,nrow =1, common.legend = T,legend = "none")

ggarrange(plotlist = list(test[[npar+2]],test[[npar+5]]), ncol = 1, nrow = 2,common.legend = T,heights = c(1,2))

```

```{r}


# saveRDS(test,file = paste("Plt_mse_sim_200_type3_",version,".rds",sep=""))
```

## 5.2.2 Violin + MSE plots

```{r}
version = "v2"
violin_plt = readRDS(paste("Plt_violin_sim_Aug_",version,".rds",sep=""))
MSE_plt = readRDS(paste("Plt_mse_sim_200_type3_",version,".rds",sep=""))


for (l in 1:npar){
  violin_plt[[4]][[l]] = violin_plt[[4]][[l]]+ theme( axis.text.y = element_text(size= 12))
# violin_plt[[7]][[l]] = violin_plt[[7]][[l]]+ theme( axis.text.y = element_text(size= 12))
  
  labs(y="estimated value")
  plt_temp = list()
  plt_temp[[1]] = ggarrange(plotlist = list(violin_plt[[4]][[l]],violin_plt[[5]][[l]],violin_plt[[6]][[l]]),nrow = 1,ncol = 3, common.legend = T)
  
  plt_temp[[2]] = ggarrange(plotlist = list(MSE_plt[[l]],violin_plt[[7]][[l]]),nrow = 1,ncol = 2, common.legend = T,widths = c(1.9,1.1),legend = "bottom")
  
  plt_temp[[3]] = ggarrange(plotlist = list(plt_temp[[1]],plt_temp[[2]]),nrow =2, ncol =1)
  
   plt_temp[[4]] = ggarrange(plotlist = list(violin_plt[[4]][[l]],violin_plt[[5]][[l]],violin_plt[[6]][[l]],violin_plt[[7]][[l]]),nrow = 1,ncol = 4, common.legend = T)
  
  # ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/MSE_violin",name[l],"_",version,".pdf",sep=""),
  #        plot   = plt_temp[[3]] ,
  #        device = cairo_pdf,  # embeds fonts better; optional
  #        width  = 8.27, height = 5.83, units = "in")
  ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/violin",name[l],"_",version,".pdf",sep=""),
         plot   = plt_temp[[4]] ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 3.6, units = "in")
  
  
}





```


## 5.3 Accuracy & Brier
```{r}
# version = "v2"
version = "v3"
acc_table = readRDS(paste("acc_table_",version,".rds",sep=""))
brier_table = readRDS(paste("brier_table_",version,".rds",sep=""))


acc_df = data.frame(size =rep(acc_table$size,2*4) ,
                    models = rep(acc_table$models,2*4),
                    acc = c(acc_table$acc_is_b,acc_table$acc_is_mle,acc_table$acc_os_b,acc_table$acc_os_mle),
                    estimate = c(rep("post. mean",length(type_set)),rep("mle est.",length(type_set)),rep("post. mean",length(type_set)),rep("mle est.",length(type_set))),
                    type = c(rep("in-sample",2*length(type_set)),rep("out-of-sample",2*length(type_set))))

brier_df = data.frame(size =rep(brier_table$size,2*4) , 
                      models = rep(brier_table$models,2*4),
                      acc = c(brier_table$brier_is_b,brier_table$brier_is_mle,brier_table$brier_os_b,brier_table$brier_os_mle),estimate = c(rep("post. mean",length(type_set)),rep("MLE",length(type_set)),rep("post. mean",length(type_set)),rep("MLE",length(type_set))),type = c(rep("in-sample",2*length(type_set)),rep("out-of-sample",2*length(type_set))))

brier_df_plt = data.frame(size =rep(brier_table$size,2*4) , 
                      models = rep(brier_table$models,2*4),
                      acc = c(brier_table$brier_is_b,brier_table$brier_is_mle,brier_table$brier_os_b,brier_table$brier_os_mle),type = c(rep("in-sample post. mean",length(type_set)),rep("in-sample mle est.",length(type_set)),rep("out-of-sample post. mean",length(type_set)),rep("out-of-sample mle est.",length(type_set))))

saveRDS(acc_df,paste("acc_df_",version,".rds",sep=""))
saveRDS(brier_df,paste("brier_df_",version,".rds",sep=""))

```

```{r}
library(ggpubr)
library(ggplot2)
plt =list()

plt[[1]] = ggplot()+
    geom_line(data = acc_df,aes(x=size,y = acc,colour = models,linetype = estimate),linewidth = 1.5, alpha = 0.6)+
    facet_grid(rows = vars(type))+            
  theme_classic()+
  labs(x = "",y = "%",title = "Predicted Accuracy")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")

plt[[2]] = ggplot()+
    geom_line(data = brier_df,aes(x=size,y = acc,colour = models),linewidth = 1.5, alpha = 0.6)+
    facet_grid(cols = c(vars(estimate), vars(type)))+
  theme_classic()+
  labs(x = "Sample Size",y = "Brier Score",title = "")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_text(size= 12),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")

plt[[3]] = ggplot()+
    geom_line(data = brier_df_plt,aes(x=size,y = acc,colour = models,linetype = type),linewidth = 1.5, alpha = 0.4)+
  theme_classic()+
  labs(x = "",y = "Brier Score",title = "")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_text(size= 12),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")
  

#ggarrange(plotlist = list(plt[[1]],plt[[2]]), ncol = 2, nrow = 1,common.legend = T)

# saveRDS(plt[[2]],file = paste("Plt_acc_",version,".rds",sep=""))

```


## 5.4 CO vs CO_adj

```{r}
df = read.csv("df_violin_sim_4type_200_v2.csv")
# df = read.csv("df_violin_sim_4type_80_v2.csv")
# df = read.csv("df_violin_sim_4type_400_v2.csv")
df = df[,-1]
colnames(df) =c(name1,"type")
head(df)
```

```{r}
library(readxl)
MLE_df = read_excel("D:/onedrive/OneDrive - National University of Singapore/MLE_df.xlsx")

res1 = MLE_df[which(MLE_df$type%in%c("CO_O","CO_R")),]
res1
true_value_sd = matrix(c(0,10,0,20,0,42,-2,2,-4,3.5,0,5.1,0,1,0,25),nrow = 2)
```


```{r}
library(ggplot2)
library(see)
library(ggpubr)
test1 = list()

i = 1
j = 1
while(i<=8){

j = i
res_tmp = data.frame(res1[seq(from = i,to = npar*2,by =npar),])
#res1_tmp = data.frame(res_tmp[which(res_tmp$type=="CO_O"),])
#res2_tmp = data.frame(res_tmp[which(res_tmp$type=="CO_R"),])
df1_tmp = df[which(df$type=="CO_O"),]
df2_tmp = df[which(df$type=="CO_R"),]

  test1[[i]]= 
ggplot()+
    geom_violinhalf(data = df2_tmp, aes_(x = "",y = df2_tmp[,j]), alpha = 0.5,trim = F,fill = "#6d1950",color = "white",flip = T)+
    geom_violinhalf(data = df1_tmp, aes_(x = "",y = df1_tmp[,j]), alpha = 0.5,trim = F,fill = "#d48849",color = "white")+
    geom_pointrange(data = res_tmp, aes(x = "", y = est,ymin = lo,ymax =up,group = type,fill = type),linewidth =0.05,shape = 24,alpha = 1,size = 0.3,position = position_dodge(width=-0.2),linetype = 0)+
    geom_errorbar(data = res_tmp, aes(x ="", y = est,ymin = lo,ymax =up,group = type,color = type),linewidth =0.5,width = 0.2,position = position_dodge(width=-0.2))+
    #geom_boxplot(data = df, aes_(x = df[,10], y = df[,j]),outlier.shape = NA,width = 0.04, color = "blue",linewidth = 0.4)+
  #geom_point(aes_(x = "", y = true_value[j]), fill = "#6d1950", shape = 21,size = 2,alpha = 0.5)+
  geom_hline(aes_(yintercept = true_value[j]),color = "#42376a", linetype = 2,linewidth =1)+
  theme_classic()+
  labs(x = "",y = name1[j])+ylim(true_value_sd[1,j],true_value_sd[2,j])+
  scale_color_discrete(type = c("#d48849","#6d1950"),labels = c("without identification","with identification"))+
  scale_fill_discrete(type = c("#d48849","#6d1950"),labels = c("without identification","with identification"))+
    theme( axis.text.x = element_text(size= 12),
          axis.text.y = element_text(size= 12),                       
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")
  i = i+1
}
```


```{r}
ggarrange(plotlist = test1,nrow = 2,ncol = 4,common.legend = T)
```


```{r}

test2 = list()

i = 1
j = 1
while(i<=8){

j = i
test2[[i]]=ggplot()+
    geom_density(data = df,aes_(x = df[,i],fill = df[,10]),alpha = 0.5,color = "white")+
  geom_vline(aes_(xintercept = true_value[j]),color = "#42376a", linetype = 2,linewidth =1)+
  theme_classic()+
  labs(x = "",y = name_df[j])+xlim(true_value_sd[1,j],true_value_sd[2,j])+
  scale_fill_discrete(type = c("#d48849","#6d1950"),name = "type",labels = c(expression(CO^O),expression(CO^R)))
  i = i+1
}#
```

```{r}
ggarrange(plotlist = test2,nrow = 2,ncol = 4,common.legend = T)
```


## 5.4 MLE and Beyesian Diagnosis Plots
### 5.4.1 Beyesian Diagnosis plots
```{r}
# trace plot to check whether the rest of chains are stable, sample size = 1e3
diagnosis_Bayesian_fun = function(type0, N, attrs,version){
  set.seed(2025)
  path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) #RTG 200

  true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               poster(para_list = list(para = 
                      c(true_param$beta,
                        true_param$zeta[-3]-true_param$zeta[3],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0)))
  
  true_value_v2 = true_value
  true_value_v2[zeta_index] =true_value_v2[zeta_index] -true_param$zeta[nAlt]
  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  Supper_chain_sd = sapply(chain_all, function(x){apply(x,2,sd)})

  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
  }
  Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  
  name1 = c(bquote(beta[A]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[B]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[C]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(zeta[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(zeta[2]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[2]~", "~.(type0)~"( "~.(sample_size)~")"), bquote("Posterior"~", "~.(type0)~"( "~.(sample_size)~")"))
  
  plt = list()
  plt$sdplt = list()
  plt$traceplt = list()
  for( i in 1:(npar+1)){
    plt_df = data.frame(value = matrix(t(Supper_chain[,,i]),ncol = 1),chain = factor(matrix(t(replicate(length(thin),1:K)),ncol = 1)),iter = matrix(replicate(K,1:length(thin)),ncol = 1))
    plt$traceplt[[i]] = ggplot()+ 
      geom_line(data =plt_df, aes(x=iter, y=value, colour = chain),alpha = 0.5)+ 
      guides(color = "none")+
      theme_classic()+
      labs(subtitle = name1[[i]])+
      geom_hline(yintercept = true_value[i],color = "red", linewidth = 1.5, alpha = 0.7, linetype = 2)
    plt$sdplt[[i]] = ggplot()+
      geom_line(data =data.frame(sd = Supper_chain_sd[i,],iter = 1:length(Supper_chain_sd[i,])), aes(x=iter, y=sd),alpha = 0.5)+
      theme_classic()+
      labs(subtitle =name1[[i]])
    
  }
  
  plt$traceplt[[npar+2]] = ggarrange(plotlist = plt$traceplt,nrow = 4,ncol = 2)
  plt$sdplt[[npar+2]] = ggarrange(plotlist = plt$sdplt,nrow = 4,ncol = 2)
  
  return(plt)
}



```

```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
plt_b = list()

m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
plt_b[[m]] = diagnosis_Bayesian_fun(type0=type0, N=N, attrs=attrs,version=version)
    m = m +1
    }
  
}
# saveRDS(plt_b,file = paste("Diagnosis/Diagnosis_plt_beyesian_",version,".rds",sep=""))

```

```{r}
m= 1;plt_b[[m]]$sdplt[[npar+2]];plt_b[[m]]$traceplt[[npar+2]]
############## save plt pdf

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    ggsave(paste("Diagnosis/Diagnosis_sim_trace_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$traceplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

    ggsave(paste("Diagnosis/Diagnosis_sim_sd_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$sdplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

   m = m+1
  }

  }

```


### 5.4.2 MLE checkplots 



```{r}

diagnosis_MLE_fun = function(type0, N, attrs,version,res_table){

name1 = c(bquote(beta[A]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[B]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[C]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(zeta[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(zeta[2]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[2]~", "~.(type0)~"( "~.(sample_size)~")"))



low = res_table$est[-(npar+1)]-abs(res_table$est[-(npar+1)]-res_table$true[-(npar+1)])-1
upper = res_table$est[-(npar+1)]+abs(res_table$est[-(npar+1)]-res_table$true[-(npar+1)])+1


low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){max(0,x)})
low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){min(200,x)})

upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){max(0,x)})
upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){min(200,x)})

low[c(npar-1,npar)] = sapply(low[c(npar-1,npar)],function(x){min(5,x)})
upper[c(npar-1,npar)] = sapply(upper[c(npar-1,npar)],function(x){min(5,x)})

plot = list()
for(i in 1:npar){
value_seq = sort(c(res_table$est[i],res_table$true[i],seq(from = low[i], to =upper[i], length.out =50)))
#MLE_value
LLK_seq = sapply(value_seq, function(x) {tmp = res_table$est[-(npar+1)];tmp[zeta_index] = tmp[zeta_index]-true_param$zeta[nAlt];
tmp[i] =x; return(LL(para = tmp, type0 = type0))})
plot[[i]] = ggplot(data = data.frame(value = value_seq,llk = LLK_seq))+geom_line(aes(x = value, y = llk))+labs(title = name1[[i]])+
  geom_vline(aes_(xintercept =res_table$true[i],color = "true") )+
  geom_vline(aes_(xintercept =res_table$est[i],color = "mle"))+
  scale_color_discrete(type = c("true" = "red","mle" = "blue"))
}

plot[[npar+1]] = ggarrange(plotlist = plot,nrow = 2,ncol = 4,common.legend = T)

return(plot)
}

```

```{r}
mle_res_table = readRDS(paste("Result_table_mle_",version,".rds",sep=""))
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
plt_mle = list()

m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

plt_mle[[m]] = diagnosis_MLE_fun(type0 = type0, N = N, attrs = attrs,version = version,res_table =mle_res_table[[m]])
    m = m +1
    }
  
}

# saveRDS(plt_mle,file = paste("Diagnosis/Diagnosis_plt_mle_",version,".rds",sep=""))


```

```{r}
# m=1;plt_mle[[m]][[npar+1]]

############## save plt pdf

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    ggsave(paste("Diagnosis/Diagnosis_sim_MLE_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_mle[[m]][[npar+1]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")
   m = m+1
  }

  }
```


## 5.5 violon plots (Supplementart version)

```{r}
# N = 200
post1 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_200_CRT.csv") #CRT
  
post2 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_200_RTG_v2.csv") # RTG

post3 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_200_CO.csv") #CO_O

post4 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_200_CO_adj_V4.csv") #CO_R
```



```{r}
# N = 80

post1 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_80_CRT_v2.csv") #CRT
  
post2 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_80_RTG_v2.csv") # RTG

post3 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_80_CO_v2.csv") #CO_O

post4 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_50_CO_adj_v2.csv") #CO_R
```


```{r}
# N = 400

post1 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_400_CRT.csv") #CRT
  
post2 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_400_RTG_v3.csv") # RTG

post3 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_500_CO.csv") #CO_O

post4 = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_400_CO_adj.csv") #CO_R
```



```{r}
library(readr)
name1 = c(expression(paste(beta[A])),
          expression(paste(beta[B])),
          expression(paste(beta[C])),
          expression(paste(zeta[1])),expression(paste(zeta[2])),
          expression(paste(lambda[1])),
          expression(paste(lambda[2])),
          "b",
          "LLK")


post1 = t(post1[,-1])
post2 = t(post2[,-1])
post3 = t(post3[,-1])
post4 = t(post4[,-1])

post1 = data.frame(post1, type = rep("CRT",dim(post1)[1]))
post2 = data.frame(post2, type = rep("RTG",dim(post2)[1]))
post3 = data.frame(post3, type = rep("CO_O",dim(post3)[1]))
post4 = data.frame(post4, type = rep("CO_R",dim(post4)[1]))
df = rbind(post1,post2,post3,post4)


colnames(df) =c(name1,"type")

name_df = c(name1[-(npar+1)],"type")
  
head(df)
# write.csv(df,"df_violin_sim_4type_400_v2.csv")

```


```{r}
df = read.csv("df_violin_sim_4type_200_v2.csv")
# df = read.csv("df_violin_sim_4type_80_v2.csv")
# df = read.csv("df_violin_sim_4type_400_v2.csv")
df = df[,-1]
colnames(df) =c(name1,"type")
head(df)
```

```{r}
library(readxl)
MLE_df = read_excel("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/2025/simulations/MLE_summary.xlsx")
head(MLE_df)
```

```{r}
# MLE_df1 = MLE_df[which((MLE_df$type!="CO_O")&MLE_df$size==200),]
# MLE_df1 = MLE_df[which((MLE_df$type!="CO_O")&MLE_df$size==400),]
MLE_df1 = MLE_df[which((MLE_df$type!="CO_O")&MLE_df$size==80),]
MLE_df1$type[which(MLE_df1$type=="CO_R")] = "CO"

df = df[which(df$type!="CO_O"),]
df$type[which(df$type=="CO_R")] = "CO"

true_value_sd = matrix(c(0,8,0,22,0,51.5,-3.8,4.4,-6.5,6.5,0,5.1,0,2.5,0,69),nrow = 2) # the y-axis boundary of plot
true_value_sd[1,] = sapply(1:npar,function(x){tmp = matrix(MLE_df1$Lo,nrow = 3,byrow = T);return(min(tmp[,x])-0.5)})
  true_value_sd[2,] = sapply(1:npar,function(x){tmp = matrix(MLE_df1$Up,nrow = 3,byrow = T);return(max(tmp[,x])+0.5)})
# true_value_sd[2,1:2] = rep(10,2)
# true_value_sd[2,3] = 20
# true_value_sd[1,4] = -2
# true_value_sd[1,5] = -4
true_value_sd[1,6:7]=-0.1
```

```{r}

library(ggpubr)
library(ggplot2)


#ggarrange

test = list()

i = 1
j = 1
while(i<=8){
  #if(i>=6) {j = i+1}
  ##else{j = i}
  j = i
  res_tmp =data.frame(MLE_df1[seq(from = i,to = npar*3,by =npar),])
  test[[i]]= ggplot()+geom_violin (data = df, aes_(x = df[,10], y = df[,j],fill = "Posterior"), alpha = 1,trim = FALSE,color = "#7A84F5",scale = "width",linewidth = 1)+
    geom_pointrange(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up, fill = "CI"),linewidth =0.5,shape = 24,alpha = 0.8,size =0.5,color = "#669157")+
    geom_errorbar(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up), color = "#669157",linewidth =0.7,width = 0.8,size = 0.8)+
    # geom_hline(aes_(yintercept = true_value[j],color = "TRUE"), linetype = 2,linewidth =1,alpha = 0.6)+
  geom_point(aes_(x =c("CO","CRT","RTG"), y = rep(true_value[j],3), fill = "TRUE"), shape = 21,size = 3,alpha = 0.6,color ="#6d1950")+
  theme_classic()+
  labs(x = "",title = name_df[j],y = "")+ylim(true_value_sd[1,j],true_value_sd[2,j])+
     theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")+
    scale_fill_manual(values = c("Posterior" = "#C4B5E0", "CI" = "#669157", "TRUE" = "#6d1950"))+
    labs(fill = "")
  
  
  if(i<=4) {test[[i]]=test[[i]]+theme( axis.text.x = element_blank(),
            axis.text.y = element_blank())}
    
  i = i+1
}
#test[[8]] = test[[8]]+coord_cartesian(ylim = c(0, 20))




ggarrange(plotlist = test, ncol = 4, nrow = 2,common.legend = T,heights = c(0.47,0.53))
```


```{r}
# saveRDS(test,"Plt_violin_sim_200_v4.rds")
```

## 5.6 MSE plots (Supplementary version)

```{r}
library(readxl)
MSE_df = read_excel("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/2025/simulations/mse_summary.xlsx")
head(MSE_df)
colnames(MSE_df) = c("param","mse","distribution","size","type")
```

```{r}

MSE_df1 = MSE_df[which(MSE_df$distribution!="CO_O"),]
MSE_df1$distribution[which(MSE_df1$distribution=="CO_R")] = "CO"
MSE_df1$size = as.factor(MSE_df1$size)
library(ggpubr)
library(ggplot2)


#ggarrange

test = list()

i = 1
j = 1
while(i<=npar){
 
  j = i
  res_tmp =data.frame(MSE_df1[seq(from = i,to = npar*3*2*3,by =npar),])
  
  test[[i]]= ggplot()+
    geom_line(data = res_tmp,aes(x=size,y = log(mse),colour = distribution,linetype = type, group = interaction(type, distribution)),linewidth = 1.5, alpha = 0.6)+
    #geom_point()+            
  theme_classic()+
  labs(x = "",y = "",title = name_df[j])+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")#+
    #scale_linetype_manual(values = c("solid","dotted"))
  if (i<5){
    test[[i]] = test[[i]]+ theme( axis.text.x = element_blank(),
          axis.text.y = element_blank(),                       
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")
  }
    
    #scale_fill_manual(values = c("Posterior" = "#C4B5E0", "CI" = "#669157", "TRUE" = "#6d1950"))+
    #labs(fill = "")
    
  i = i+1
}
test[[1]] = test[[1]] + labs(y = "log(MSE)")
test[[5]] = test[[5]] + labs(y = "log(MSE)")
test[[8]] = test[[8]] + labs(x = "sample size")
ggarrange(plotlist = test, ncol = 4, nrow = 2,common.legend = T)
```

```{r}
# saveRDS(test,"Plt_mse_sim_200_type3.rds")
```



## 5.7 Contour plot (Supplementary version)

Compare CRT between recised MLBA and Hancock's version

```{r}
df_contour = data.frame(t(post))#[,-(npar+1)]
 #name1
#name1 = c(expression(beta[RC]),expression(beta[OC]),expression(beta[DR]),expression(zeta[ICEV]),expression(zeta[EVA]),
          #expression(zeta[EVB]),
#          expression(I0),
#          expression(lambda[1]),expression(lambda[2]),"b","LLK")



name1 = c(expression(beta[A]),expression(beta[B]),expression(beta[C]),expression(zeta[1]),expression(zeta[2]),
          #expression(zeta[EVB]),
          expression(I0),
          expression(lambda[1]),expression(lambda[2]),"b","LLK")

colnames(df_contour) = name1#c("betaRC","betaOC","betaDR","zeta(ICAEV)", "zeta(EVA)","lam1" ,"lam2" ,"b","llk")
head(df_contour)



#( 3.563 , 49.841 )
#( 0.004 , 23.333 )
#( 1.054 , 11.178 )
#( -3.955 , 3.736 )
#( 1.374 , 4.009 )
#( 0.521 , 1 )
#( 0.05 , 0.374 )
#( 4.965 , 13.383 )


# Set the x-axis range
df_tmp = data.frame(`beta[A]`= c(0,3),`beta[B]`= c(0,10),`beta[C]` =c(0,30),`zeta[1]` = c(-3,0),`zeta[2]` = c(-3,0),
                    `I[0]` = c(0,5),
                    `lambda[1]` = c(0.2,5),`lambda[2]` = c(0,1),`b` = c(9,15),`LLK` = c(-1e3,-1e3))

#df_tmp = data.frame(`beta[RC]`= c(0,25),`beta[OC]`= c(0,50),`beta[DR]` =c(0,15),`zeta[ICEV]` = c(-25,5),`zeta[EVA]` = c(0,4),`lambda[1]` = c(0,1 ),`lambda[2]` = c(0,1),`b` = c(3,15),`LLK` = c(-1e3,-1e3))

#df_tmp = data.frame(`beta[RC]`= c(0,50),`beta[OC]`= c(0,50),`beta[DR]` =c(0,10),`zeta[ICEV]` = c(-4,4),`zeta[EVA]` = c(-1,4),`lambda[1]` = c(0,1 ),`lambda[2]` = c(0,1),`b` = c(3,15),`LLK` = c(-1e3,-1e3))

#colnames(df_tmp) =  name1

df_contour = rbind(df_contour,df_tmp)
#write.csv(df_contour, "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\simulations\\df_plot_CRTH(9)_May15.csv")
```


```{r}

library(GGally)

# create pairs plot



diag_plot = function(data,mapping,...){

  ggplot(data = data, mapping = mapping )+ 
   geom_histogram(bins = 30, fill = "grey",color = "black", alpha = 0.5)#+
}

lower_plot = function(data,mapping,Lik = df_contour[,(npar+1)],true = true_value,  median =  post_median,...){
 # j<<-  j+1
  ggplot(data = data, mapping = mapping)+
  #ggplot(data = data, mapping = mapping)+
  theme_classic()+labs(x = "",y="")+
  theme(legend.position = "none") + 
  scale_color_gradient(high = "pink", low = "blue")+
  geom_point(aes(color = Lik), alpha = 0.1, cex = 0.1)+
  geom_density2d( color = "#7A84F5")
      
}


plot_canvas = ggpairs( df_contour[,1:npar],
                       diag = list(continuous = wrap(diag_plot, bins = 30)),
                       lower = list(continuous = wrap(lower_plot) ))+
                       theme(plot.margin =unit( c(0.1,0.1,0.1,0.1), "lines")) 
                       
                       
  
#print(plot_canvas)

```



```{r}



plot_all = plot_canvas

k = 2
while(k<=npar){
  j = 1
    while(j<=(k-1)){
      
    plot_all[k,j] = plot_all[k,j]+
      annotate(geom = "point", x = true_value[j], y = true_value[k], shape = 21, size = 2, fill = "#669157")+
      annotate(geom = "point", x = post_mean[j], y = post_mean[k], shape = 21, size = 2, fill = "blue")+xlim(df_tmp[1,j],df_tmp[2,j])+ylim(df_tmp[1,k],df_tmp[2,k])
   j = j+1
    }
  k = k+1
  
}

yend = c(M/3,M/3,M/3,M/3*2,M,M/3*2,M/3,M*1.2,M/2)

for( i in 1:npar){
    plot_all[i,i] = plot_all[i,i]+
    annotate("segment" , x = true_value[i],y = 0,xend = true_value[i] ,yend =yend[i] ,color = "#669157",   linewidth = 1.2)+
    annotate("segment" , x =post_mean[i],y = 0,xend =  post_mean[i] ,yend =yend[i],color = "blue",   linewidth = 1.2)+labs()+xlim(df_tmp[1,i],df_tmp[2,i])
}
# print(plot_all)
```






# 6. RUM check
```{r}
library(gmnl)
library(mlogit)
library(readr)
```


```{r}
choice = function(c){
  #c is the index of chosen alternative
  
  tmp = matrix(0,nrow = nAlt, ncol = length(c))
  for( i in 1:N){
    tmp[c[i],i] = 1
  }
  return(matrix(tmp,ncol = 1))
}


df_long = data.frame(attrs,Alt = rep(1:3,N),chosen = X_wide$chosen,income = log(df_raw$income) )
colnames(df_long) = c("RC_scaled","OC_scaled","ln_DR_scaled","Alt","chosen","income")
head(df_long)

```

```{r}
df_mnl = mlogit.data(df_long, choice = "chosen", shape = "long", alt.levels = c("3","1","2"),alt.var = "Alt")

m1.t = gmnl(chosen~RC_scaled+OC_scaled+ln_DR_scaled|1|0, data = df_mnl)

summary(m1.t)
# -187.31
# attraction -125.38 scale-invariant
# attraction -116.06 with income factors
# -519.54 for online
```
```{r}
MNL_prob = m1.t$prob.alt
tmp = MNL_prob[,1]
MNL_prob[,1:2] = MNL_prob[,2:3]
MNL_prob[,3] = tmp
MNL_c = apply(MNL_prob,1,which.max)

sum(MNL_c==df0$rc)/length(df0$rc)*100
#60.28369 with log( income), pure attribute
# 46.80851 with log(income), log(DR)
# 69.86755 for online attraction 
```










# Others

```{r}
# p-p plot based on condition
library(tidyr)
library(dplyr)
df_new = data.frame(df_raw[,1:4], RC = attrs[,1], OC = attrs[,2],DR = attrs[,3],rt = df_raw$rt)
real_p = df_new%>% group_by(Scenario) %>%nest()
df_pp = data.frame(Scenario = NULL,real_prob = NULL, Alt_type = NULL, est_prob = NULL)
est_para1 = post_median[-(npar+1)]#est_MLE[MLE_index,]#post_mean[-(npar+1)]#est_MLE[MLE_index,]


for(i in 1:length(real_p$Scenario)){
  data_tmp =real_p$data[[i]]
  temp_chosen = matrix(data_tmp$chosen,nrow = nAlt) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))

  I0_est =  est_para1[npar-3]           
  
  est_prob = sapply(1:nAlt, function(x){
    #MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],   b = est_para1[npar] , A =  est_para1[npar]+true_param$A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  #discard_index = which(apply(est_prob, 1, sum)<1e-5)
  #discard_index = which((est_prob[,1]==est_prob[,2])& (est_prob[,1]>=est_prob[,3]))
  
  
  
  quantile_est = colMeans(est_prob)
  #if(length(discard_index)!=0){
   # est_choice = apply(est_prob[-discard_index,], 1, which.max)
  #  quantile_est = c((sum(est_choice==1)+length(discard_index)/2)/dim(est_prob)[1],(sum(est_choice==2)+length(discard_index)/2)/dim(est_prob)[1],sum(est_choice==3)/dim(est_prob)[1] )
  #}
  #else{
  #  est_choice = apply(est_prob, 1, which.max)
  #  quantile_est = c(sum(est_choice==1)/dim(est_prob)[1],sum(est_choice==2)/dim(est_prob)[1],sum(est_choice==3)/dim(est_prob)[1] )
  #}
  
  # +length(discard_index)
  df_tmp = data.frame(Scenario = rep(str_sub(real_p$Scenario[i],start = 1,end = 4),nAlt),real_prob = Prob_real, Alt_type = c("competitor","target", "decoy" ), est_prob =  quantile_est,ratio = rep(quantile_est[2]/quantile_est[1], 3))
  
  df_pp = rbind(df_pp,df_tmp)
  
}


df_pp
#write.csv(df_pp,"Df for P-P lab_Attraction_RTG(2)")

#0.4324324/0.4054054	/0.1621622
#0.3896104/0.4935065/0.1168831

#0.4110214/ 0.449456/
```




```{r}
ggplot(data = df_pp)+geom_point(aes(x =real_prob, y = est_prob,shape = Scenario, col = Alt_type ))+
    geom_abline(aes(intercept = 0, slope = 1))+
    labs(title = "P-P plot for Attraction Effect")+
    theme_classic()+
    coord_cartesian(xlim = c(0,1),ylim = c(0,1))
  
```
```{r}
df_new = data.frame(df_raw[,1:4], RC = attrs[,1], OC = attrs[,2],DR = attrs[,3],rt = df_raw$rt)
seq_decoy = seq(from =3 ,to = dim(df_new)[1],by = 3)
df_new = df_new[-seq_decoy,]

real_p = df_new%>% group_by(Scenario) %>%nest()
df_pp2 = data.frame(Scenario = NULL,real_prob = NULL, Alt_type = NULL, est_prob = NULL)
est_para1 = post_median


for(i in 1:length(real_p$Scenario)){
  data_tmp =real_p$data[[i]]
  
  temp_chosen = matrix(data_tmp$chosen,nrow = 2) 
  Prob_real = rowSums(temp_chosen)/sum(rowSums(temp_chosen))

  I0_est =  est_para1[npar-3]           
  #est_prob = sapply(1:nAlt, function(x){MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 3))[,1])} )
  est_prob = sapply(1:2, function(x){MLBA_rtknown_all(X = as.matrix(data_tmp[,c(4,5,6)]),beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-4)]), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = I0_est , b = est_para1[npar] , A =  est_para1[npar]*true_param$b_A, s = true_param$s, choice =rep(x,length(unique(data_tmp$ID))) , rt = t(matrix(data_tmp$rt,nrow = 2))[,1])} )
  
  #discard_index = which(apply(est_prob, 1, sum)<1e-5)
 
  #discard_index = which(sapply(1:dim(est_prob)[1], function(i){est_prob[i,1]==est_prob[i,2]}))
  #est_choice = apply(est_prob[-discard_index,], 1, which.max)
  
  
  
  
  #quantile_est = c((sum(est_choice==1)+length(discard_index)/2)/dim(est_prob)[1],(sum(est_choice==2)+length(discard_index)/2)/dim(est_prob)[1] )
  quantile_est = colMeans(est_prob)
  
  

  df_tmp = data.frame(Scenario = rep(str_sub(real_p$Scenario[i],start = 1,end = 4),2),real_prob = Prob_real, Alt_type = c("competitor","target" ), est_prob =  quantile_est, ratio = rep(quantile_est[2]/quantile_est[1],2))
  
  df_pp2 = rbind(df_pp2,df_tmp)
  
}


df_pp2[which((df_pp2$est_prob!=0 )& (df_pp2$est_prob!=1 )),]

```


```{r}

d_est = sapply(1:nAlt,function(i){sapply(1:N, function(x){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),], beta = est_para1[1:nAttr], zeta = c(est_para1[(nAttr+1):(npar-3)],0), lam1 =est_para1[npar-2] ,lam2 = est_para1[npar-1],  I0 = est_para1[npar-3], choice = i)})})

#d_real = sapply(1:N, function(x){RCPPdriftmean(X = attrs[((x-1)*nAlt+1):(x*nAlt),], beta = true_param$beta, zeta = true_param$zeta, lam1 =true_param$lam1 ,lam2 = true_param$lam2,  I0 = true_param$I0,choice = df$chosen[x])}) 

#data.frame(d_est,d_real)

#sum(d_est<d_real)
head(d_est)
sum(rowSums(d_est)==0)

# all d_est is lower estimated, So does d. Therefore, I0 and d should have some relation
rc = apply(d_est[which((rowSums(d_est)!=0)&(d_est[,1]!=d_est[,2]) ),],1,which.max)
summary(as.factor(rc))
# 351 253 

```



### Comparision it with the estimated version 
index 1 and index 2

```{r}
line5 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[1:nAlt,],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)
                                                                                      
line6 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt+1):(2*nAlt),],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)
line6_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA(X = attrs[(nAlt*74+1):(75*nAlt),],beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0,choice = c,rt = x)}); return(temp)})),ncol = 1)

line7 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[1:nAlt,], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line8 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(nAlt+1):(2*nAlt),], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

line8_2 = matrix(t(sapply(rt,function(x){temp = sapply(1:nAlt, function(c){RCPPpdf_MLBA_rtknown(X = attrs[(74*nAlt+1):(75*nAlt),], beta = est_para1[1:2], zeta = c(est_para1[3:4],0), lam1 =true_param$lam1 ,lam2 = est_para1[6],  I0 = est_para1[5],b = est_para1[7],  A = est_para1[7]/10, s = true_param$s0, choice = c, rt = x)}); return(temp)})),ncol = 1)

pdf = c(line5,line6, line6_2)
cdf = c(line7,line8, line8_2)

Real = rep("Est_MLE",3*nAlt*5e2)


temp =data.frame(RT = RT, pdf = pdf, Alt = Alt, Obs = Obs, Real = Real, cdf = cdf)


df_plot_1 = rbind(df_plot, temp)

```


```{r}
ggplot(df_plot_1 )+geom_line(mapping = aes(x = RT, y = pdf, color = Alt), alpha = 1, linewidth = 1, linetype = "3313")+
  theme_bw() +  
  labs( x = "Response time", y = "pdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real),scales = "free")+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
```
```{r}
ggplot(df_plot_1 )+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha =0.5, position = position_dodge(width = 0))+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
  
ggplot(df_plot_1 )+geom_area(mapping = aes(x = RT, y = cdf, fill = Alt), alpha =0.7, position = "stack")+
  theme_bw() +  
  labs( x = "Response time", y = "cdf",title ="MLBA prob distribution ")+
  theme(legend.position = "right")+
  facet_grid(cols = vars(Obs), rows = vars(Real))+
  scale_color_discrete(type = c("#D33F6A","#669157","#7A84F5"))
```


