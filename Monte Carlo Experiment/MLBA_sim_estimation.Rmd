---
title: "MLBA estimation on simulated dataset"
author: "Xinwei Li\n li.xinwei@u.nus.edu"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
      highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())


```

# 1. Data import
```{r, echo=FALSE, message=FALSE,results='hide'}
library(tictoc)
library(doParallel)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
library(RcppNumerical)
library(plyr)
library(data.table)
library(readr)
library(crayon)
library(ggplot2)
library(bayestestR)
library(coda)
library(beepr)
file_route = "D:\\onedrive\\OneDrive - National University of Singapore\\Desktop\\New folder\\MLBA_CRT\\RT_paper\\MLBA.cpp"
df = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0801_800.csv")


df_test = read_csv("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/MLBARCT_data_0801_800(test).csv")

sourceCpp(file = file_route)
```

# 2. MLBA prepration
## 2.1 hyperparameter setting

```{r}
true_param = list( lam1 = 1, lam2 = 0.5, zeta = c(0.3,-0.5,1), beta = c(1,2,5), s0 = 1, b = 10, A = 0,alpha = -1,attention = 0, type =1)
sourceCpp(file_route)
nAttr = 3
nAlt = 3
npar = (nAlt-1)+nAttr +2 +0
zeta_index =(nAlt+1):(nAlt+nAttr-1)
```

## 2.2 De-MCMC setup
```{r}

# function to retrive choice-RT and attribute infos from given dataframe
 df_info = function(df){
  res = list()  # four iterms: N;attrs;RC;RT
  # observation number
  res$N = nrow(df)
  # build attrs matrix 
  X_wide = df[,3:ncol(df)]
  tmp = unlist(sapply(1:res$N, function(x){return(matrix(X_wide[x,]))})) 
  X_long = t(matrix(tmp,nrow = nAttr,byrow =F))
  attrs = X_long 
  res$attrs = sapply(1:nAttr, function(x){(unlist(attrs[,x])-min(unlist(attrs[,x])))/(max(unlist((attrs[,x])))-min(unlist(attrs[,x])))})  # normalized attributes value to [0,1]

  # value RT and RC
  res$RC = df$chosen; res$RT = df$RT
  return(res)
}

##########################################
# self-designed parameter transformation 
para_fun=function(para){
  current_para_list = list()
  current_para_list$beta = para[1:nAttr]
  current_para_list$zeta = c(para[(nAttr+1)]+true_param$zeta[nAlt],para[(nAttr+2)]+true_param$zeta[nAlt],+true_param$zeta[nAlt])
  current_para_list$lam1 = para[npar-1]
  current_para_list$lam2 = para[npar]
  current_para_list$A = true_param$A
  current_para_list$b = true_param$b+true_param$A
  current_para_list$s0 =true_param$s0
  return(current_para_list)
}

###########################################################
# function to return the log-posterior of given parameter
poster = function(para_list){
  
  para = as.numeric(para_list$para)
  type = para_list$type
  prior = rep(-1,length(para))
  
  prior[zeta_index] = dunif(para[zeta_index], min = -100, max = 100,log = T)
  prior[-zeta_index] = dunif(para[-zeta_index], min = 0, max = 200,log = T)
  #prior[-zeta_index] = dunif(para[-zeta_index], min = -3, max = 7,log = T)
  prior[(npar-1):npar] =  dunif(para[(npar-1):(npar)], min = 0, max = 5,log = T)
  # prior[(npar-2):(npar-1)] = dunif(para[(npar-2):(npar-1)], min = 0, max = 5,log = T)
  #prior[(npar-1)] = dunif(para[(npar-1)], min = 0, max = 5,log = T)
  #prior[npar] = dunif(para[npar], min = 0, max = 1,log = T)
 
  
  para_tmp = para_fun(para = para)
  
if(type=="CRT"){
 temp = sum(prior) +  RCPPMLBA_Lik_rtknown(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
   
}else if(type=="RTG"){
  temp = sum(prior) +  RCPPMLBA_Lik_rtg(X = attrs,beta = para_tmp$beta, zeta = para_tmp $zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC, rt = RT)
    
}else{
  temp = sum(prior) + RCPPMLBA_Lik_CO(X = attrs,beta = para_tmp$beta, zeta = para_tmp$zeta,lam1 = para_tmp$lam1,lam2 = para_tmp$lam2,b = para_tmp$b, s = para_tmp$s0, A =para_tmp$A, choice = RC)
    
}
  if(is.na(temp)) temp = -Inf
  
  return (temp)
}
############################################
# initial function
chain_intial = function(type0,K,npar){
# initialize chains. the last column is for likelihood
chain_int = matrix(nrow = K, ncol = npar+1)
chain_list = list()
theta_0 = chain_int

  theta_0[,zeta_index] = runif(K*length(zeta_index), min = -100, max = 100)
  theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 200)
  theta_0[,-c(zeta_index,npar+1)] = runif(K*(npar-length(zeta_index)), min = 0 , max = 5)

theta_0[,(npar+1)] = sapply(1:K, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0) ))})

# check whether All Likelihood is smaller than Inf
index = which(is.infinite(theta_0[,(npar+1)]))

while (length(index)) {
  
  theta_0[index,zeta_index] = runif(length(index)*length(zeta_index), min =-100, max = 100)
  theta_0[index,-c(zeta_index,npar+1)] = runif(length(index)*(npar-length(zeta_index)), min = 0, max = 200)
  theta_0[index,(npar-1):(npar)] = runif(length(index)*2, min = 0 , max = 5)
  

  theta_0[index,(npar+1)] = sapply(index, function(x){return (poster(para_list = list(para = theta_0[x,-(npar+1)], type = type0)))})
  index = which(is.infinite(theta_0[,(npar+1)]))

  # print(paste("Still has", length(index), "to find."))
}
chain_list[[1]] = theta_0

return(chain_list)
}

###########################################
# cross-over step
Update_para = function(para){
  # para = list(ChainIndex,last_chainlist,gamma)
  # last_chainlist is a matrix each row means the last step value of each chain and the last column is the liklihood of the corresponding parameters
 
  theta_prev = para$last_chain[para$ChainIndex,-(npar+1)]
  # randomly draw two chain from all chains except current chain
  de_ChainIndex = sample(probset[-para$ChainIndex], size = 2,replace = FALSE)
  theta_m = para$last_chain[de_ChainIndex[1],-(npar+1)] 
  theta_n = para$last_chain[de_ChainIndex[2],-(npar+1)] 
  # generate new theta, the here are 6 parameters to estimate in total
  add = runif(npar, min = -0.05, max = 0.05)#npar
  theta_new = theta_prev + para$gamma* (theta_m - theta_n) + add
  
  new_post = poster(para_list = list(para = theta_new, type = type0) )
  prev_post = para$last_chain[para$ChainIndex,(npar+1)]

  # accept rate
  alpha = runif(1)
  
  ratio = exp(new_post-prev_post)
  #if(is.na(ratio)) ratio = 0
  if( alpha> ratio) temp = c(theta_prev,prev_post) else temp = c(theta_new,new_post)
    
  
  return(temp)
}
######################################### 
## update chains
De_MCMC_unit = function(prev, X, gam1){
  
  para = list(ChainIndex = X, last_chain = prev, gamma = gam1)#runif(1,.5,1)
  Update_para(para)
}

#########################################
# migrate step
migrate_step = function(current_chain_list){
    temp_ssize = ceiling(runif(1,min = 1, max = K))
    temp_sample =sample(1:K,temp_ssize,replace = FALSE)
    
    theta_res = current_chain_list[temp_sample[1],]
    for (g in 1:temp_ssize){
     temp_theta = current_chain_list[temp_sample[g],-(npar+1)]
     add = runif(npar, min = -0.05, max = 0.05)#npar
    
      if(g==1) new_theta = current_chain_list[temp_sample[temp_ssize],-(npar+1)] +add
     # previous item 
      else  new_theta = theta_res[-(npar+1)] + add
     
      new_post = poster(para_list = list(para = new_theta, type = type0))
      prev_post = theta_res[(npar+1)]
      theta_res = current_chain_list[temp_sample[g],]
      
      alpha = runif(1)
      ratio = exp(new_post-prev_post)
      #if(is.na(ratio)) ratio = 0
      if(alpha<ratio)  current_chain_list[temp_sample[g],] = c(new_theta,new_post)
    }
    
    return(current_chain_list)
}
###########################################
# parall_computing

demcmc_fun = function(chain_list, burn_in, M, mig_rate, type0, probset, K, N, npar, RC, RT, attrs,version,continuous = 0){
  
for (j in (1+continuous):(M+continuous)) {

  chain_list[[j+1]] = t(parSapply(X = 1:K, FUN = De_MCMC_unit, prev = chain_list[[j]], gam1 = gam, cl = cl))
  
  # immigration step (only works at certain steps at early stage)
  if ((j<round(continuous+burn_in*0.75))&(runif(1)<mig_rate)){
chain_list[[j+1]] = migrate_step(current_chain_list = chain_list[[j+1]])}
  if(type0=="CO"){
    if(j%%1e2==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  else{
    if(j%%1e3==0) message(paste("Simulation progress:" ,round(j/(M+continuous)*100,2) ,"% has finished.",sep = " "))
  }
  
  if(j%%1000==0) {saveRDS(chain_list, file = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep=""))}
  } 
  
return(list(chain_list=chain_list,path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")))
}
########################################
# result generation
result_fun = function(type0, N, attrs,version){
  set.seed(2025)
  path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) #RTG 200

  est1 = sapply(chain_all[thin], colMeans)
  est2 = sapply(chain_all, function(x){apply(x,2,sd)})
  est3 = sapply(chain_all[thin], function(x){apply(x, 2, median)})
  est3[zeta_index,] = est3[zeta_index,] +true_param$zeta[3]
  est_median = est3

  true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               poster(para_list = list(para = 
                      c(true_param$beta,
                        true_param$zeta[-3]-true_param$zeta[3],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0)))
  true_value_v2 = true_value
  true_value_v2[zeta_index] =true_value_v2[zeta_index] -true_param$zeta[nAlt]
  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
    post_mcerror[j] =sd(post[j,])/sqrt(2*effectiveSize(post[j,]))
    post_mse[j] = sqrt(mean((post[j,]-true_value_v2[j])^2))
  }
  #Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  
  post_mean = apply(post,1, mean)
  post_mean[npar+1] = poster(para_list = list(para = post_mean[-(npar+1)],type = type0))
  post_mean[zeta_index] = post_mean[zeta_index]+true_param$zeta[3]
    
  post_median = apply(post , 1, median)
  post_median[npar+1] = poster(para_list = list(para = post_median[-(npar+1)],type = type0))
  post_median[zeta_index] = post_median[zeta_index]+true_param$zeta[3]
  
  post[zeta_index,] = post[zeta_index,]+true_param$zeta[3]
  Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  name = c("betaA","betaB","betaC", "zeta1","zeta2", "lam1", "lam2" ,"Lik")
  
  HDI_para = apply(post, 1,function(x){temp = hdi(x, ci = 0.95, verbose = FALSE); return (c(temp$CI_low, temp$CI_high))},simplify = TRUE)
  MLE_value[zeta_index] = MLE_value[zeta_index]+true_param$zeta[3]
  result4 = data.frame( true =true_value,
                        est_mean = round(post_mean,3),
                        est_median = round(post_median,3), 
                        sd = round(post_sd,3),
                        hdi_95 = c(sapply(1:npar, function(x){paste("( ", round(t(HDI_para)[x,1],3),", ",round(t(HDI_para)[x,2],3),")")}),"-"),
                        mse = round(post_mse,3),
                        MLE = round(est_MLE[MLE_index,],3))#,
                        #mcmc_error = post_mcerror)
                        #bias = sapply(round((est_MLE[MLE_index,]-true_value)/true_value*100,2), function(x){paste(x,"%")}))
  post_app = rep(NULL,npar+1)
  rownames(result4) = name
  write.csv(post,paste("Post_sim_",N,"_",type0,"Aug_",version, ".csv",sep=""))
  return(result4)
  write.csv(result4,paste0(type0,"_post_",N,version,".rds",".csv",step = ""))
}


```

## 2.3 MLE setup
```{r}
library(optimParallel)
##############################
# likelihood function
LL = function(para,type0){
  temp = poster(para_list = list(para = para, type0 = type0))#-log(1/200)*(npar-2)-log(1/5)*2
  if(is.na(temp)) temp = -Inf
  if(is.infinite(temp)|temp<(-1e10)) temp = -1e10
  return(temp)
}

gn = function(para,type0){
  para_list = para_fun(para = para)
 if(type0=="CRT"){
   temp = score_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = score_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = score_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b = para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
  # temp = numDeriv::grad(func = LL1,x = para)
  # temp = temp[-(nAttr+nAlt-1+2-1)]
  for(tempi in 1:length(temp)){
    if(is.na(temp[tempi])) temp[tempi] = 0
  if(is.infinite(temp[tempi])) {
    if(temp[tempi]>0) {temp[tempi] = 1e6}
    else {temp[tempi] = -1e6}
  }
    }
  return(temp)
}

gnBHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = t(sapply(1:N, function(x){score_mlba_crt_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else if (type0 == "RTG"){
   temp = t(sapply(1:N, function(x){score_mlba_rtg_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x], rt = RT[x])}))
 }else{
   temp = t(sapply(1:N, function(x){score_mlba_co_all(attrs[(nAlt*(x-1)+1):(nAlt*x),],beta =  para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC[x])}))
 }
  return(temp)
}

Hessian_BHHH =  function(para,type0){
 para_list = para_fun(para = para)
 if(type0 == "CRT"){
   temp = derivative_mlba_crt_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else if (type0=="RTG"){
   temp = derivative_mlba_rtg_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC, rt = RT)
 }else{
   temp = derivative_mlba_co_all(attrs,beta = para_list$beta,zeta = para_list$zeta,lam1 = para_list$lam1,lam2 = para_list$lam2,b =para_list$b, s = para_list$s0, A =para_list$A, choice = RC)
 }
 for(tmpi in 1:dim(temp)[1]){
   for(tmpj in 1:dim(temp)[2]){
     if(is.na(temp[tmpi,tmpj])) temp[tmpi,tmpj] = 0
     else if (is.infinite(temp[tmpi,tmpj])) {
       if(temp[tmpi,tmpj>0]) temp[tmpi,tmpj]=1e6
       else temp[tmpi,tmpj]=-1e6
     }
     
     }}
 
  return(temp)
}
#########################
mle_fun = function(type0, N, attrs, npar, RC, RT, try_times, MAP_value,Mean_value,Median_value,L_vec,cl,pgtol,version){
  # set up mle
  set.seed(2025)
  est_mle1_adj_v1 = matrix(nrow = npar+1, ncol = try_times)
  mle1_list_adj_v1 = list()
  mle1_list_sd_v1 = list()
  i = 1;k = 1
 
  while(i<=try_times){
      if(k==1){
        par_value = MAP_value
      }
      else if(k==2) {
        par_value = Mean_value
      }
    else if(k==3) {
        par_value = Median_value
      }
      else {
      tmp_alpha = runif(1)
      tmpt_value = ifelse(tmp_alpha<0.5,ifelse(tmp_alpha<0.2,Mean_value,Median_value),MAP_value)
      tmpt_value = MAP_value
      if(k<50){
        
       noise = runif(npar,min = -1,max = 1)
      noise[(npar-1):(npar)] =  runif(2,min = - 0.1,max = 0.1) 
      }else if (k<100){
        if(k==51) message("has tried 50 different initial values.")
        noise = runif(npar,min = -5,max = 5)
      noise[(npar-1):(npar)] =  runif(2,min = - 0.5,max = 0.5) 
      }else{
        if(k==101) message("has tried 100 different initial values.")
        noise = runif(npar,min = -10,max = 10)
      noise[(npar-1):(npar)] =  runif(2,min = - 1,max = 1) 
      }
      
      
      par_value = tmpt_value + noise  
      par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(max(x,0))})
      par_value[-zeta_index] = sapply(par_value[-zeta_index],function(x){return(min(x,200))})
      par_value[c(npar-1,npar)] = sapply(par_value[c(npar-1,npar)],function(x){return(max(x,0))})
      par_value[c(npar-1,npar)] = sapply(par_value[c(npar-1,npar)],function(x){return(min(x,5))})
      
      
    }
  OK = tryCatch(
    { k = k+1
      mle1 = optimParallel(par = par_value,
      fn = LL1, gr = gn1, 
      method = "L-BFGS-B",
      lower = c(0,0,0,-100,-100,0,0), #7
      upper = c(200,200,200,100,100,5,5), #7
      control = list(fnscale = -1,#maxit = 1e4,
                     # ndeps = c(1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3,1e-3),
                     #pgtol = pgtol,
                     trace = 0),
      # hessian = ifelse(type0=="CO",TRUE,FALSE),
        # TRUE,
                     #pgtol = 1e-3*npar),
      parallel = list(cl=cl))
if(k==2){message(paste("The MLE estimation of ",type0," with " ,N, " has started:",sep=""))
  # message(mle1)
  }
if(is.na(mle1$convergence)) {FALSE}
else{
  if (mle1$convergence!= 0) {FALSE}
else{
    w_matrix = L_vec%*%Hessian_BHHH(para = as.numeric(mle1$par),type0 = type0)%*%t(L_vec)
  if(det(w_matrix)==0){
    flag = 0
   
  }else{
    sd.hat = tryCatch(sqrt(diag(solve(-w_matrix))),error =function(e) {NA},warning =function(w){NA} )
 
    flag = (!is.infinite(sum(sd.hat)))& (!is.na(sum(sd.hat)))
    
  }
   
  if(flag){
    mle1_list_adj_v1[[i]] = mle1 
    mle1_list_sd_v1[[i]] = sd.hat
    est_mle1_adj_v1[-(npar+1),i] = mle1$par
    est_mle1_adj_v1[(npar+1),i] =  mle1$value
    
    TRUE
    }else{FALSE}
    
    }
}

    },
  error=function(e){return(FALSE)})
  if (OK){
    if (type0=="CO"){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
      if(i%%5==0){
        saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
      }}
    else if (i%%3 ==0){
      message(sprintf("%d%% candidates have been found.", round(i/try_times*100)))
    }
  
    i = i+1 } else {next}
  
  if(k==250){
    message("200 attempts have been made. quite the process now")
  break}
  }

  
  
  saveRDS(est_mle1_adj_v1,paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_adj_v1, paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))
  saveRDS(mle1_list_sd_v1, paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep=""))

  }
#########################

#######################
result_mle_fun = function( type0, N, attrs, npar, RC, RT,try_times,L_vec,pgtol,version ){
    true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               LL(para = 
                      c(true_param$beta,
                        true_param$zeta[-nAlt]-true_param$zeta[nAlt],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0))
  est_mle1_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_est_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_adj_v1 = readRDS(file = paste(type0,"(",npar,")","_object_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))
  mle1_list_sd_v1 = readRDS(file =  paste(type0,"(",npar,")","_sd_sim_MLE",try_times,"Aug_",N,version,".rds",sep = ""))

# tol_check = sapply(1:try_times,function(tryi){tmp = max(gn1(est_mle1_adj_v1[-(npar+1),tryi])/N);ifelse(tmp<=pgtol,1,Inf)})

tol_check = rep(1,try_times)


index = which.max(est_mle1_adj_v1[(npar+1),]*tol_check)
crt_para = est_mle1_adj_v1[,index]
crt_para[zeta_index] = crt_para[zeta_index]+true_param$zeta[nAlt]
crt_mle = mle1_list_adj_v1[[index]]
crt_mle_value = crt_para
res_mle = data.frame(true = true_value,est =round(crt_para,3),se = c(round(mle1_list_sd_v1[[index]],3),"-"),gr =c( gn1(est_mle1_adj_v1[-(npar+1),index])/N,"-"),eigen_value = round(c(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value,max(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index], type0 = type0)%*%t(L_vec)))$value)/min(eigen(solve(-L_vec%*%Hessian_BHHH(para = est_mle1_adj_v1[-(npar+1),index],type0 = type0)%*%t(L_vec)))$value)),3))
return(res_mle)
}

```


# 3. MLBA Estimation
## 3.1 Bayesian estimation by De-MCMC
```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
K = npar*3; M = 8e3; burn_in = 4e3;mig_rate = 0.3; gam = 2.38/sqrt(2*npar);probset = 1:K  

## MCMC hyper-parameters setting for M,burn_in, and mig_rate##

# CRT 6e3; 3e3;0.35 for all
# RTG 6e3; 3e3;0.35 for [11,14,17,20];0.7 for [2,5,8];
# CO 6e3; 3e3;0.35 for all; 9e3; 4e3;0.25 for [6,9,15,21]; 8e3; 4e3;0.3 for [18]
############################### parallel computing setup
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
numCores = min(K,detectCores()-2)
# use enough cores to do parallel computation ,but not overload CPU
cl = makeCluster(numCores) 
# registerDoParallel(cl=cl)
# settings for parallel computing
clusterEvalQ(cl=cl, {library("doParallel");library("parallel");library("foreach");library("Rcpp");library("RcppArmadillo");library("truncnorm");library("RcppNumerical")})

clusterExport(cl = cl, c("file_route","true_param", "De_MCMC_unit", "poster", "Update_para", "K","gam", "npar",  "nAlt", "zeta_index" ,"nAttr", "para_fun", "migrate_step","probset"), envir = .GlobalEnv) 
clusterEvalQ(cl=cl, sourceCpp(file_route))

########################################
m = 1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
    
clusterExport(cl = cl, c("N", "RT", "RC", "type0","attrs"), envir = .GlobalEnv)

chain_list = chain_intial(type0=type0, K = K,npar = npar)

## If continune the previous MCMC sampling ##
# chain_list = readRDS(file = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep=""))

chain_list = demcmc_fun(chain_list = chain_list, burn_in = burn_in,
                        mig_rate = mig_rate, type0 = type0, K = K, N=N,
                        npar = npar,RC = RC, RT = RT, attrs = attrs,probset = probset,M = M, version = version,continuous = 0)
toc()
    }
    m = m+1
  }
}

stopCluster(cl=cl);doParallel::stopImplicitCluster()
```



```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
result_table = list()
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

    result_table[[m]] = result_fun(type0 = type0,N = N, attrs = attrs,version = version)
    print(paste(N, "of MLBA",type0,"result has been printed.",sep = " "))
    m = m+1
  }}


saveRDS(result_table,paste("Result_table_bayesian_",version,".rds",sep=""))

```



## 3.2. MLE estimation
```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO") 
version = "v2"

try_times = 30; max_index = nAttr+nAlt-1+2+1; L_vec = diag(1,nrow = max_index-1,ncol = max_index); pgtol = 1e-3;

#####################
# ensure no stale sockets
try(closeAllConnections(), TRUE); gc()
# parallel estimation set up
numCores = detectCores()-1
# numCores = min(1+2*npar,detectCores()-2)  
# set the number of processor cores
cl = parallel::makeCluster(numCores) 
parallel::clusterEvalQ(cl, {
  # Optional: keep each worker single-threaded to avoid nested threading
  Sys.setenv(OMP_NUM_THREADS="1", OPENBLAS_NUM_THREADS="1", MKL_NUM_THREADS="1",
             VECLIB_MAXIMUM_THREADS="1", NUMEXPR_NUM_THREADS="1")
  if (requireNamespace("RhpcBLASctl", quietly = TRUE)) {
    RhpcBLASctl::blas_set_num_threads(1)
    RhpcBLASctl::omp_set_num_threads(1)
  }
  NULL
})

parallel::clusterEvalQ(cl = cl, {library(Rcpp); library(RcppArmadillo); library(truncnorm); library(RcppNumerical); library(numDeriv);})
clusterExport(cl = cl, c("file_route","true_param", "npar",  "nAlt","zeta_index" ,"nAttr", "df", "LL","gn","poster","para_fun","L_vec","max_index"), envir = .GlobalEnv)
clusterEvalQ(cl = cl, sourceCpp(file_route))
message("The parallel setting has been done.")
#####################
  

result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep = "") )
mle_res_table = list()

m = 1

for(sample_size in sample_size_set){
  for(type0 in type_set){

    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

tic(paste0(type0," for ",N, " observations simulation takes:",sep=""))
  LL1 = function(para) LL(para = para, type0 = type0)
gn1 = function(para) L_vec %*% gn(para = para, type0 = type0)
  MAP_value = result_table[[m]]$MLE[-(npar+1)]
  MAP_value[zeta_index] = MAP_value[zeta_index]-true_param$zeta[nAlt]
  Mean_value =result_table[[m]]$est_mean[-(npar+1)]
  Mean_value[zeta_index] = Mean_value[zeta_index]-true_param$zeta[nAlt]
  Median_value =result_table[[m]]$est_median[-(npar+1)]
  Median_value[zeta_index] = Median_value[zeta_index]-true_param$zeta[nAlt]
  
  parallel::clusterExport(cl = cl,
  c("type0","N","attrs","RC","RT","MAP_value","LL1","gn1"),envir = environment())

  mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, MAP_value = MAP_value,Mean_value = Mean_value,Median_value = Median_value, L_vec = L_vec, cl = cl, pgtol = pgtol,version = version)
  toc()
}
  m = m+1
  }
  }
  
  


stopCluster(cl=cl);doParallel::stopImplicitCluster()

```

```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
try_times = 30; max_index = nAttr+nAlt-1+2+1;L_vec = diag(1,nrow = max_index-1,ncol = max_index);pgtol = 1e-2;
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep=""))
mle_res_table = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    LL1 = function(para){
    return(LL(para = para,type0 = type0))
  }
    gn1 = function(para){
      temp = gn(para = para,type0 = type0)
      res =  L_vec%*%temp 
    return(res)
    }
   
   
mle_res_table[[m]] = result_mle_fun(type0 = type0, N = N, npar = npar, attrs = attrs, RT = RT, RC = RC, try_times = try_times, L_vec = L_vec, pgtol = pgtol,version = version)
m = m+1
  }}


saveRDS(mle_res_table,paste("Result_table_mle_",version,".rds",sep=""))
```

## 4. Accuracy Calculation
```{r}
acc= function(para,type0,RC,RT,attrs,N){
  prob = NULL
  for (j in 1:nAlt){
  para_list = para_fun(para = para)
  if(type0=="CRT"){
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))
  }else if(type0=="RTG"){
    temp = MLBA_rtg_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N), rt = RT)
  }else{
    temp = RCPPcdf_MLBA_CO_all(X = attrs,beta = para_list$beta, zeta = para_list$zeta, lam1 = para_list$lam1 ,lam2 = para_list$lam2,  b =para_list$b, A = para_list$A, s = para_list$s0, choice = rep(j,N))}
  prob = cbind(prob,temp)
  }
  
  prob_brier = t(apply(prob,1,function(x){return(x/sum(x))}))
  tmp = matrix(0,ncol = nAlt, nrow = N)
  for( i in 1:N){
    tmp[i,RC[i]] = 1
  }

  brier = sum((tmp-prob_brier)**2)/N 
    
  discard = which((prob[,1]==prob[,2])|(prob[,3]==prob[,2])|(prob[,1]==prob[,3]))
  #discard = integer(0)
  if(length(discard)==0) {chosen_est = apply(prob, 1, which.max)

  acc = sum(chosen_est==RC)/N*100}
  else{
    chosen_est = rep(-1,dim(prob)[1])
    chosen_est[-discard] = apply(prob[-discard,], 1, which.max)

    acc = sum(chosen_est[-discard]==RC[-discard])/(N-length(discard))*100
  }
  
  
  
  
  
  return(list(acc = round(acc,1),brier = round(brier,3),dis = length(discard)))

}
```

```{r}
# acc table generation
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep=""))
result_mle_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))

acc_res_table = list()
m=1
acc_res_table$acc = list()
acc_res_table$brier= list()
for(sample_size in sample_size_set){
  # training set
  basic_Info = df_info(df = df[1:sample_size,])
  N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
  # test set
  basic_Info_test = df_info(df = df_test[1:sample_size,])
  N_test = basic_Info_test$N;attrs_test = basic_Info_test$attrs; RT_test = basic_Info_test$RT; RC_test = basic_Info_test$RC;
  
  # acc
  
  mean_b_crt = result_table[[(m-1)*length(type_set)+1]]$est_mean[-(npar+1)]
  mean_b_crt[zeta_index] = mean_b_crt[zeta_index]-true_param$zeta[nAlt]
  mle_crt = result_mle_table[[(m-1)*length(type_set)+1]]$est[-(npar+1)]
  mle_crt[zeta_index] = mle_crt[zeta_index]-true_param$zeta[nAlt]
  
  mean_b_rtg = result_table[[(m-1)*length(type_set)+2]]$est_mean[-(npar+1)]
  mean_b_rtg[zeta_index] = mean_b_rtg[zeta_index]-true_param$zeta[nAlt]
  mle_rtg = result_mle_table[[(m-1)*length(type_set)+2]]$est[-(npar+1)]
  mle_rtg[zeta_index] = mle_rtg[zeta_index]-true_param$zeta[nAlt]
  
  mean_b_co = result_table[[m*length(type_set)]]$est_mean[-(npar+1)]
  mean_b_co[zeta_index] = mean_b_co[zeta_index]-true_param$zeta[nAlt]
  mle_co = result_mle_table[[m*length(type_set)]]$est[-(npar+1)]
  mle_co[zeta_index] = mle_co[zeta_index]-true_param$zeta[nAlt]

  acc_res_table$acc[[m]] = data.frame(size = rep(sample_size,length(type_set)),
                                      models = type_set,
                                      acc_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mean_b_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$acc),
                                      acc_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$acc,acc(para = mle_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$acc),
                                      acc_os_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mean_b_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mean_b_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc),
                                      acc_os_mle = c(acc(para = mle_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mle_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc,acc(para = mle_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$acc))
  
  # brier
  acc_res_table$brier[[m]] = data.frame(size = rep(sample_size,length(type_set)),
                                        models = type_set,
                                        brier_is_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mean_b_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mean_b_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$brier),
                                      brier_is_mle = c(acc(para = mle_crt, type0 = "CRT", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mle_rtg, type0 = "RTG", N = N, attrs = attrs, RT = RT, RC = RC)$brier,acc(para = mle_co, type0 = "CO", N = N, attrs = attrs, RT = RT, RC = RC)$brier),
                                      brier_os_b = c(acc(para = mean_b_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mean_b_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mean_b_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier),
                                      brier_os_mle = c(acc(para = mle_crt, type0 = "CRT", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mle_rtg, type0 = "RTG", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier,acc(para = mle_co, type0 = "CO", N = N_test, attrs = attrs_test, RT = RT_test, RC = RC_test)$brier))  
    
   m = m+1 
  
}
acc_table = rbindlist(acc_res_table$acc)
brier_table = rbindlist(acc_res_table$brier)

version = "v3"
saveRDS(acc_table,paste("acc_table_",version,".rds",sep=""))
saveRDS(brier_table,paste("brier_table_",version,".rds",sep=""))


print(acc_table);print(brier_table)
```



# 5. Plots
## 5.1 violon plot

```{r,warning=FALSE}
# posterior dataset generation
sample_size_set = c(50,80,100,200,400,600,800)
version = "v2"
post_list = list()
m = 1
for(sample_size in sample_size_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
 
  post_crt = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","CRT","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

  post_rtg = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","RTG","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

  post_co = read_csv(file = paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/simulations/Post_sim_",N,"_","CO","Aug_",version,".csv",sep = ""),show_col_types = FALSE)

name1 = c(bquote(beta[A]~", "~.(sample_size)), bquote(beta[B]~", "~.(sample_size)), bquote(beta[C]~", "~.(sample_size)), bquote(zeta[1]~", "~.(sample_size)),bquote(zeta[2]~", "~.(sample_size)),bquote(lambda[1]~", "~.(sample_size)),bquote(lambda[2]~", "~.(sample_size)),"LLK")
post_crt = t(post_crt[,-1])
post_rtg = t(post_rtg[,-1])
post_co = t(post_co[,-1])
post_crt = data.frame(post_crt, type = rep("CRT",dim(post_crt)[1]))
post_rtg = data.frame(post_rtg, type = rep("RTG",dim(post_rtg)[1]))
post_co = data.frame(post_co, type = rep("CO",dim(post_co)[1]))
df_tmp = rbind(post_crt,post_rtg,post_co)
colnames(df_tmp) =c(name1,"type")
name_df = c(name1[-(npar+1)],"type")
post_list[[m]] = df_tmp
print(paste("Posteriors for observations whose size is", sample_size_set[m],"has been generated."))
m = m+1

}

saveRDS(post_list,file = paste("df_violin_sim_3type_Aug",version,".rds",sep = ""))

```

```{r}
# MLE dataset generation
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
name = c("betaA","betaB","betaC","zeta1","zeta2","lam1","lam2")
version = "v2"
mle_res_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))
MLE_df_tmp = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    MLE_df_tmp[[m]] = data.frame(param = name, est = mle_res_table[[m]]$est[-(npar+1)],  se = as.numeric(mle_res_table[[m]]$se[-(npar+1)]), type = rep(type0,npar),  size     = rep(N,npar), Lo = round(mle_res_table[[m]]$est[-(npar+1)]+as.numeric(mle_res_table[[m]]$se[-(npar+1)])*qnorm(0.025),3),   Up = round(mle_res_table[[m]]$est[-(npar+1)]+as.numeric(mle_res_table[[m]]$se[-(npar+1)])*qnorm(0.975),3))
   m = m+1 
  }}
MLE_df  = rbindlist(MLE_df_tmp)

MLE_df$Lo = sapply(1:nrow(MLE_df),function(i){
  if(!MLE_df$param[i]%in%c("zeta1","zeta2")){return(max(0,MLE_df$Lo[i]))}else{return(MLE_df$Lo[i])}})
MLE_df$Up = sapply(1:nrow(MLE_df),function(i){
  if(MLE_df$param[i]%in%c("betaA","betaB","betaC")){return(min(200,MLE_df$Up[i]))}else if(MLE_df$param[i]%in%c("lam1","lam2")){
    return(min(5,MLE_df$Up[i]))}else{return(MLE_df$Up[i])}})
head(MLE_df)

saveRDS(MLE_df,file = paste("df_violin_sim_3type_mle_Aug_",version,".rds",sep=""))
```


```{r}

true_value_sd = matrix(c(0,8,0,22,0,51.5,-3.8,4.4,-6.5,6.5,0,5.1,0,2.5),nrow = 2) # the y-axis boundary of plot

########### for partial sample sizes
# MLE_df_sub = MLE_df[which(MLE_df$size%in%c(50,100,200,400,600,800)),]
# sample_size_set_sub = c(200,400,600,800)

############ for all sample sizes
MLE_df_sub = MLE_df
sample_size_set_sub = sample_size_set
  
true_value_sd[1,] = sapply(1:npar,function(x){tmp = matrix(MLE_df_sub$Lo,nrow = 3*length(sample_size_set_sub),byrow = T);return(min(tmp[,x])-1)})
true_value_sd[2,] = sapply(1:npar,function(x){tmp = matrix(MLE_df_sub$Up,nrow = 3*length(sample_size_set_sub),byrow = T);return(max(tmp[,x])+1)})
true_value_violin = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2)

```

```{r}

library(ggpubr)
library(ggplot2)
library(ggplotify)


test = list()


m = 1
while (m<=length(sample_size_set)) {
test[[m]] = list()
sample_size = sample_size_set[m]
i = 1
j = 1
while(i<=npar){
  j = i
  MLE_df1 = MLE_df[which(MLE_df$size==sample_size),]
  post_df1 = post_list[[m]]
  res_tmp =data.frame(MLE_df1[seq(from = i,to = npar*3,by =npar),])
  name1 = c(bquote(beta[A]~", "~.(sample_size)), bquote(beta[B]~", "~.(sample_size)), bquote(beta[C]~", "~.(sample_size)), bquote(zeta[1]~", "~.(sample_size)),bquote(zeta[2]~", "~.(sample_size)),bquote(lambda[1]~", "~.(sample_size)),bquote(lambda[2]~", "~.(sample_size)),"LLK")
  
  
  test[[m]][[i]]= ggplot()+geom_violin (data = post_df1, aes_(x = post_df1[,(npar+2)], y = post_df1[,j],fill = "Posterior"), alpha = 1,trim = FALSE,color = "#7A84F5",scale = "width",linewidth = 1)+
    geom_pointrange(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up, fill = "CI"),linewidth =0.5,shape = 24,alpha = 0.8,size =0.5,color = "#669157")+
    geom_errorbar(data = res_tmp, aes(x = type, y = est,ymin = Lo,ymax =Up), color = "#669157",linewidth =0.7,width = 0.8,size = 0.8)+
    # geom_hline(aes_(yintercept = true_value[j],color = "TRUE"), linetype = 2,linewidth =1,alpha = 0.6)+
  geom_point(aes_(x =c("CO","CRT","RTG"), y = rep(true_value_violin[j],3), fill = "TRUE"), shape = 21,size = 3,alpha = 0.6,color ="#6d1950")+
  theme_classic()+
  labs(x = "",title = name1[[j]],y = "")+ylim(true_value_sd[1,j],true_value_sd[2,j])+
     theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")+
    scale_fill_manual(values = c("Posterior" = "#C4B5E0", "CI" = "#669157", "TRUE" = "#6d1950"))+
    labs(fill = "")
  i = i+1
}

g = ggplotGrob(test[[m]][[1]])
leg = g$grobs[[which(sapply(g$grobs, `[[`, "name") == "guide-box")]]
test[[m]][[npar+1]] = as.ggplot(leg)
m = m+1

}


saveRDS(test,paste("Plt_violin_sim_Aug_",version,".rds",sep=""))
```

```{r}

for (l in 1:npar){
plt_tmp = ggarrange(plotlist = list(test[[1]][[l]],test[[2]][[l]],test[[3]][[l]],test[[4]][[l]],test[[5]][[l]],test[[6]][[l]],test[[7]][[l]],test[[1]][[npar+1]]),ncol = 4, nrow = 2,common.legend = T,legend = "none")
ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/Full_violin",name[l],"_",version,".pdf",sep=""),
         plot   = plt_tmp ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 6.5, units = "in")
  
  
}


```

```{r}
for (m in 1:length(sample_size_set)){
plt_tmp = ggarrange(plotlist = list(test[[m]][[1]],test[[m]][[2]],test[[m]][[3]],test[[m]][[4]],test[[m]][[5]],test[[m]][[6]],test[[m]][[7]],test[[m]][[npar+1]]),ncol = 4, nrow = 2,common.legend = T,legend = "none")
ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/Full_violin(",sample_size_set[m],")_",version,".pdf",sep=""),
         plot   = plt_tmp ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 6.5, units = "in")
  
  
}
```

## 5.2 MSE plot

```{r}
version = "v2"
result_table = readRDS(file = paste("Result_table_bayesian_",version,".rds",sep="") )

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
name = c("betaA","betaB","betaC","zeta1","zeta2","lam1","lam2")
MSE_df_tmp = list()
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    
    MSE_df_tmp[[m]] = data.frame(param = name, mse = result_table[[m]]$mse[-(npar+1)], distribution = rep(type0,npar),  size = rep(N,npar),estimate = rep("post",npar))
   m = m+1 
  }}

mle_res_table = readRDS(file = paste("Result_table_mle_",version,".rds",sep=""))
for(sample_size in sample_size_set){
  for (type0 in type_set){
    basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
    tmpt_m =  m-length(sample_size_set)*length(type_set)
    MSE_df_tmp[[m]] = data.frame(param = name, mse = round(sqrt(abs(mle_res_table[[tmpt_m]]$true[-(npar+1)]-mle_res_table[[tmpt_m]]$est[-(npar+1)])^2+as.numeric(mle_res_table[[tmpt_m]]$se[-(npar+1)])^2),3), distribution = rep(type0,npar),  size = rep(N,npar),estimate = rep("mle",npar))
   m = m+1 
  }}


MSE_df  = rbindlist(MSE_df_tmp)

head(MSE_df)
saveRDS(MSE_df,paste("df_sim_3type_mse_Aug_",version,".rds",sep=""))

```




```{r}
library(ggpubr)
library(ggplot2)
library(grid)
# MSE_df$size = as.factor(MSE_df$size)
name_df = c(expression(beta[A]), expression(beta[B]), expression(beta[C]), expression(zeta[1]),expression(zeta[2]),expression(lambda[1]),expression(lambda[2]),"LLK")

test = list()
i = 1
j = 1
while(i<=npar){
 
  j = i
  res_tmp =data.frame(MSE_df[seq(from = i,to = npar*length(sample_size_set)*2*length(type_set),by =npar),])
  
  test[[i]]= ggplot()+
    geom_line(data = res_tmp,aes(x=size,y = log(mse),colour = distribution,linetype = estimate, group = interaction(estimate, distribution)),linewidth = 1.5, alpha = 0.6)+
  theme_classic()+
  labs(x = "",y = "",title = name_df[j])+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")
    
    
  i = i+1
}
test[[1]] = test[[1]] + labs(y = "log(MSE)")
test[[nAttr+1]] = test[[nAttr+1]] + labs(y = "log(MSE)")
test[[npar-1]] = test[[npar-1]] + labs(y = "log(MSE)")

test[[2]] = test[[2]] + labs(x = "sample size")
test[[npar-1]] = test[[npar-1]] + labs(x = "sample size")
test[[npar]] = test[[npar]] + labs(x = "sample size")


library(ggplotify)

g <- ggplotGrob(test[[1]])
leg <- g$grobs[[which(sapply(g$grobs, `[[`, "name") == "guide-box")]]
test[[npar+1]] = as.ggplot(leg)

test[[npar+2]] = ggarrange(plotlist = list(test[[1]],test[[2]],test[[3]]),ncol = 3,nrow =1, common.legend = T,legend = "none")
test[[npar+3]] = ggarrange(plotlist = list(test[[4]],test[[6]]),ncol = 1,nrow =2, common.legend = T,legend = "none")
test[[npar+4]] = ggarrange(plotlist = list(test[[5]],test[[7]]),ncol = 1,nrow =2, common.legend = T,legend = "none")

test[[npar+5]] = ggarrange(plotlist = list(test[[npar+3]],test[[npar+1]],test[[npar+4]]),ncol = 3,nrow =1, common.legend = T,legend = "none")

ggarrange(plotlist = list(test[[npar+2]],test[[npar+5]]), ncol = 1, nrow = 2,common.legend = T,heights = c(1,2))

```

```{r}


# saveRDS(test,file = paste("Plt_mse_sim_200_type3_",version,".rds",sep=""))
```

## 5.2.2 Violin + MSE plots

```{r}
version = "v2"
violin_plt = readRDS(paste("Plt_violin_sim_Aug_",version,".rds",sep=""))
MSE_plt = readRDS(paste("Plt_mse_sim_200_type3_",version,".rds",sep=""))


for (l in 1:npar){
  violin_plt[[4]][[l]] = violin_plt[[4]][[l]]+ theme( axis.text.y = element_text(size= 12))
# violin_plt[[7]][[l]] = violin_plt[[7]][[l]]+ theme( axis.text.y = element_text(size= 12))
  
  labs(y="estimated value")
  plt_temp = list()
  plt_temp[[1]] = ggarrange(plotlist = list(violin_plt[[4]][[l]],violin_plt[[5]][[l]],violin_plt[[6]][[l]]),nrow = 1,ncol = 3, common.legend = T)
  
  plt_temp[[2]] = ggarrange(plotlist = list(MSE_plt[[l]],violin_plt[[7]][[l]]),nrow = 1,ncol = 2, common.legend = T,widths = c(1.9,1.1),legend = "bottom")
  
  plt_temp[[3]] = ggarrange(plotlist = list(plt_temp[[1]],plt_temp[[2]]),nrow =2, ncol =1)
  
   plt_temp[[4]] = ggarrange(plotlist = list(violin_plt[[4]][[l]],violin_plt[[5]][[l]],violin_plt[[6]][[l]],violin_plt[[7]][[l]]),nrow = 1,ncol = 4, common.legend = T)
  
  # ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/MSE_violin",name[l],"_",version,".pdf",sep=""),
  #        plot   = plt_temp[[3]] ,
  #        device = cairo_pdf,  # embeds fonts better; optional
  #        width  = 8.27, height = 5.83, units = "in")
  ggsave(paste("D:/onedrive/OneDrive - National University of Singapore/Desktop/New folder/MLBA_CRT/RT_paper/R&R/violin",name[l],"_",version,".pdf",sep=""),
         plot   = plt_temp[[4]] ,
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 3.6, units = "in")
  
  
}





```


## 5.3 Accuracy & Brier
```{r}
# version = "v2"
version = "v3"
acc_table = readRDS(paste("acc_table_",version,".rds",sep=""))
brier_table = readRDS(paste("brier_table_",version,".rds",sep=""))


acc_df = data.frame(size =rep(acc_table$size,2*4) ,
                    models = rep(acc_table$models,2*4),
                    acc = c(acc_table$acc_is_b,acc_table$acc_is_mle,acc_table$acc_os_b,acc_table$acc_os_mle),
                    estimate = c(rep("post. mean",length(type_set)),rep("mle est.",length(type_set)),rep("post. mean",length(type_set)),rep("mle est.",length(type_set))),
                    type = c(rep("in-sample",2*length(type_set)),rep("out-of-sample",2*length(type_set))))

brier_df = data.frame(size =rep(brier_table$size,2*4) , 
                      models = rep(brier_table$models,2*4),
                      acc = c(brier_table$brier_is_b,brier_table$brier_is_mle,brier_table$brier_os_b,brier_table$brier_os_mle),estimate = c(rep("post. mean",length(type_set)),rep("MLE",length(type_set)),rep("post. mean",length(type_set)),rep("MLE",length(type_set))),type = c(rep("in-sample",2*length(type_set)),rep("out-of-sample",2*length(type_set))))

brier_df_plt = data.frame(size =rep(brier_table$size,2*4) , 
                      models = rep(brier_table$models,2*4),
                      acc = c(brier_table$brier_is_b,brier_table$brier_is_mle,brier_table$brier_os_b,brier_table$brier_os_mle),type = c(rep("in-sample post. mean",length(type_set)),rep("in-sample mle est.",length(type_set)),rep("out-of-sample post. mean",length(type_set)),rep("out-of-sample mle est.",length(type_set))))

saveRDS(acc_df,paste("acc_df_",version,".rds",sep=""))
saveRDS(brier_df,paste("brier_df_",version,".rds",sep=""))

```

```{r}
library(ggpubr)
library(ggplot2)
plt =list()

plt[[1]] = ggplot()+
    geom_line(data = acc_df,aes(x=size,y = acc,colour = models,linetype = estimate),linewidth = 1.5, alpha = 0.6)+
    facet_grid(rows = vars(type))+            
  theme_classic()+
  labs(x = "",y = "%",title = "Predicted Accuracy")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_blank(),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "bottom")

plt[[2]] = ggplot()+
    geom_line(data = brier_df,aes(x=size,y = acc,colour = models),linewidth = 1.5, alpha = 0.6)+
    facet_grid(cols = c(vars(estimate), vars(type)))+
  theme_classic()+
  labs(x = "Sample Size",y = "Brier Score",title = "")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_text(size= 12),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")

plt[[3]] = ggplot()+
    geom_line(data = brier_df_plt,aes(x=size,y = acc,colour = models,linetype = type),linewidth = 1.5, alpha = 0.4)+
  theme_classic()+
  labs(x = "",y = "Brier Score",title = "")+ theme( axis.text.x = element_text(size= 12),
            axis.text.y = element_text(size= 12),
         axis.title = element_text(size= 12),
         title = element_text(size= 12),
         legend.text = element_text(size  = 12),
         legend.title = element_text(size  = 12),
         strip.text = element_text(size  = 12),
         legend.position = "right")
  

#ggarrange(plotlist = list(plt[[1]],plt[[2]]), ncol = 2, nrow = 1,common.legend = T)

# saveRDS(plt[[2]],file = paste("Plt_acc_",version,".rds",sep=""))

```


## 5.4 MLE and Beyesian Diagnosis Plots
### 5.4.1 Beyesian Diagnosis plots
```{r}
# trace plot to check whether the rest of chains are stable, sample size = 1e3
diagnosis_Bayesian_fun = function(type0, N, attrs,version){
  set.seed(2025)
  path = paste0("chain_list_",type0,"_sim","(",npar,")_",N,version,".rds",sep="")
  chain_all = readRDS(file = path)
  npar = dim(chain_all[[1]])[2]-1
  K = dim(chain_all[[1]])[1]
  M = length(chain_all)-1
  burn_in = round(M/2,0)
  
  
  thin = sort(sample((burn_in*1.5):(M),300,replace = F)) #RTG 200

  true_value = c(true_param$beta,
               true_param$zeta[-3],
               true_param$lam1,
               true_param$lam2,
               # true_param$b+true_param$A,
               poster(para_list = list(para = 
                      c(true_param$beta,
                        true_param$zeta[-3]-true_param$zeta[3],
                        true_param$lam1,
                        true_param$lam2),
                        #true_param$b),
                 type = type0)))
  
  true_value_v2 = true_value
  true_value_v2[zeta_index] =true_value_v2[zeta_index] -true_param$zeta[nAlt]
  # DE_MLE
  est_MLE = rbind.fill.matrix(chain_all)
  MLE_index = which.max(est_MLE[,(npar+1)])
  MLE_value = est_MLE[MLE_index,]
  #
  Supper_chain = array(dim = c(K,length(thin),npar+1))
  for(i in 1:K){
  Supper_chain[i,,] = t(sapply(chain_all[thin], function(x){return(x[i,])}))
  }
  Supper_chain_sd = sapply(chain_all, function(x){apply(x,2,sd)})

  post = matrix(nrow = npar+1,ncol = K*length(thin))
  post_sd = rep(NULL,npar+1)
  post_mcerror = rep(NULL,npar+1)
  post_mse = rep(NULL,npar+1)
  for (j in 1:(npar+1)){
    post[j,] = matrix(Supper_chain[,,j],nrow = 1)
    post_sd[j] = sd(post[j,])
  }
  Supper_chain[,,zeta_index] = Supper_chain[,,zeta_index]+true_param$zeta[3]
  
  
  name1 = c(bquote(beta[A]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[B]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[C]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(zeta[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(zeta[2]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[2]~", "~.(type0)~"( "~.(sample_size)~")"), bquote("Posterior"~", "~.(type0)~"( "~.(sample_size)~")"))
  
  plt = list()
  plt$sdplt = list()
  plt$traceplt = list()
  for( i in 1:(npar+1)){
    plt_df = data.frame(value = matrix(t(Supper_chain[,,i]),ncol = 1),chain = factor(matrix(t(replicate(length(thin),1:K)),ncol = 1)),iter = matrix(replicate(K,1:length(thin)),ncol = 1))
    plt$traceplt[[i]] = ggplot()+ 
      geom_line(data =plt_df, aes(x=iter, y=value, colour = chain),alpha = 0.5)+ 
      guides(color = "none")+
      theme_classic()+
      labs(subtitle = name1[[i]])+
      geom_hline(yintercept = true_value[i],color = "red", linewidth = 1.5, alpha = 0.7, linetype = 2)
    plt$sdplt[[i]] = ggplot()+
      geom_line(data =data.frame(sd = Supper_chain_sd[i,],iter = 1:length(Supper_chain_sd[i,])), aes(x=iter, y=sd),alpha = 0.5)+
      theme_classic()+
      labs(subtitle =name1[[i]])
    
  }
  
  plt$traceplt[[npar+2]] = ggarrange(plotlist = plt$traceplt,nrow = 4,ncol = 2)
  plt$sdplt[[npar+2]] = ggarrange(plotlist = plt$sdplt,nrow = 4,ncol = 2)
  
  return(plt)
}



```

```{r}
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
plt_b = list()

m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;
plt_b[[m]] = diagnosis_Bayesian_fun(type0=type0, N=N, attrs=attrs,version=version)
    m = m +1
    }
  
}
# saveRDS(plt_b,file = paste("Diagnosis/Diagnosis_plt_beyesian_",version,".rds",sep=""))

```

```{r}
m= 1;plt_b[[m]]$sdplt[[npar+2]];plt_b[[m]]$traceplt[[npar+2]]
############## save plt pdf

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    ggsave(paste("Diagnosis/Diagnosis_sim_trace_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$traceplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

    ggsave(paste("Diagnosis/Diagnosis_sim_sd_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_b[[m]]$sdplt[[npar+2]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")

   m = m+1
  }

  }

```


### 5.4.2 MLE checkplots 



```{r}

diagnosis_MLE_fun = function(type0, N, attrs,version,res_table){

name1 = c(bquote(beta[A]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[B]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(beta[C]~", "~.(type0)~"( "~.(sample_size)~")"), 
            bquote(zeta[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(zeta[2]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[1]~", "~.(type0)~"( "~.(sample_size)~")"),
            bquote(lambda[2]~", "~.(type0)~"( "~.(sample_size)~")"))



low = res_table$est[-(npar+1)]-abs(res_table$est[-(npar+1)]-res_table$true[-(npar+1)])-1
upper = res_table$est[-(npar+1)]+abs(res_table$est[-(npar+1)]-res_table$true[-(npar+1)])+1


low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){max(0,x)})
low[-(zeta_index)] = sapply(low[-(zeta_index)],function(x){min(200,x)})

upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){max(0,x)})
upper[-(zeta_index)] = sapply(upper[-(zeta_index)],function(x){min(200,x)})

low[c(npar-1,npar)] = sapply(low[c(npar-1,npar)],function(x){min(5,x)})
upper[c(npar-1,npar)] = sapply(upper[c(npar-1,npar)],function(x){min(5,x)})

plot = list()
for(i in 1:npar){
value_seq = sort(c(res_table$est[i],res_table$true[i],seq(from = low[i], to =upper[i], length.out =50)))
#MLE_value
LLK_seq = sapply(value_seq, function(x) {tmp = res_table$est[-(npar+1)];tmp[zeta_index] = tmp[zeta_index]-true_param$zeta[nAlt];
tmp[i] =x; return(LL(para = tmp, type0 = type0))})
plot[[i]] = ggplot(data = data.frame(value = value_seq,llk = LLK_seq))+geom_line(aes(x = value, y = llk))+labs(title = name1[[i]])+
  geom_vline(aes_(xintercept =res_table$true[i],color = "true") )+
  geom_vline(aes_(xintercept =res_table$est[i],color = "mle"))+
  scale_color_discrete(type = c("true" = "red","mle" = "blue"))
}

plot[[npar+1]] = ggarrange(plotlist = plot,nrow = 2,ncol = 4,common.legend = T)

return(plot)
}

```

```{r}
mle_res_table = readRDS(paste("Result_table_mle_",version,".rds",sep=""))
sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
plt_mle = list()

m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
basic_Info = df_info(df = df[1:sample_size,])
    N = basic_Info$N;attrs = basic_Info$attrs; RT = basic_Info$RT; RC = basic_Info$RC;

plt_mle[[m]] = diagnosis_MLE_fun(type0 = type0, N = N, attrs = attrs,version = version,res_table =mle_res_table[[m]])
    m = m +1
    }
  
}

# saveRDS(plt_mle,file = paste("Diagnosis/Diagnosis_plt_mle_",version,".rds",sep=""))


```

```{r}
# m=1;plt_mle[[m]][[npar+1]]

############## save plt pdf

sample_size_set = c(50,80,100,200,400,600,800)
type_set = c("CRT","RTG","CO")
version = "v2"
m=1
for(sample_size in sample_size_set){
  for (type0 in type_set){
    ggsave(paste("Diagnosis/Diagnosis_sim_MLE_",type0,"_","(",sample_size,")" ,"_",version,".pdf",sep=""),
         plot   = plt_mle[[m]][[npar+1]],
         device = cairo_pdf,  # embeds fonts better; optional
         width  = 8.27, height = 5.83, units = "in")
   m = m+1
  }

  }
```

